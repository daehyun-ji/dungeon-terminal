<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë˜ì „ íƒí—˜</title>
    <!-- Tailwind CSS CDN ë¡œë“œ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Retro í„°ë¯¸ë„ ëŠë‚Œì„ ìœ„í•œ í°íŠ¸ ì„¤ì • */
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #000000; /* ê²€ì€ìƒ‰ ë°°ê²½ */
            color: #E0E0E0; /* ë°ì€ íšŒìƒ‰/í°ìƒ‰ ê¸€ì”¨ */
            overflow: hidden; 
            font-size: clamp(0.8rem, 2vw, 1rem); 
        }
        /* ê²Œì„ ì˜ì—­ì— ë ˆíŠ¸ë¡œí•œ ë…¹ìƒ‰ í…Œë‘ë¦¬ ì¶”ê°€ */
        .game-area {
            border: 4px solid #00aa00;
            box-shadow: 0 0 10px #00aa00;
        }
        /* ë˜ì „ ë·°í¬íŠ¸ (ASCII ì•„íŠ¸ê°€ ê¹¨ì§€ì§€ ì•Šë„ë¡ pre-wrap ì‚¬ìš©) */
        #dungeon-viewport {
            white-space: pre; 
            line-height: 1; 
            font-size: 1rem;
            color: #E0E0E0;
            user-select: none; 
        }
        /* ê°œë³„ íƒ€ì¼ ìŠ¤íƒ€ì¼ */
        .player { color: #ffff00; /* ë…¸ë€ìƒ‰: @ */ }
        .wall { color: #555555; /* ì–´ë‘ìš´ íšŒìƒ‰: # */ }
        .floor { color: #444444; /* ì•„ì£¼ ì–´ë‘ìš´ íšŒìƒ‰: . */ }
        .stairs { color: #00ffff; /* ë°ì€ ì²­ë¡ìƒ‰: > */ }
        .item { color: #ff00ff; /* ë§ˆì  íƒ€: % */ }
        
        /* ëª¬ìŠ¤í„° ìŠ¤íƒ€ì¼ */
        .monster-S { color: #ff8800; /* ì£¼í™©ìƒ‰: í˜ì˜ ì •ìˆ˜ ë“œë ëª¬ìŠ¤í„° */ }
        .monster-H { color: #00ff00; /* ë…¹ìƒ‰: ì²´ë ¥ì˜ ì •ìˆ˜ ë“œë ëª¬ìŠ¤í„° */ }
        .monster-Y { color: #0088ff; /* íŒŒë€ìƒ‰: íšŒí”¼ì˜ ì •ìˆ˜ ë“œë ëª¬ìŠ¤í„° */ }
        .monster-P { color: #8800ff; /* ë³´ë¼ìƒ‰ */ }
        .monster-O { color: #ff0088; /* í•‘í¬ìƒ‰ */ }

        /* ë³´ìŠ¤ ëª¬ìŠ¤í„° ìŠ¤íƒ€ì¼: ë¶‰ê²Œ ë¹›ë‚˜ëŠ” íš¨ê³¼ */
        .boss-glow {
            color: #ff4444; /* Bright Red */
            text-shadow: 0 0 5px #ff0000, 0 0 10px #880000; 
        }

        /* ìƒˆë¡œìš´ ìŠ¤íƒ€ì¼: í•œ ë²ˆ ë´¤ì§€ë§Œ í˜„ì¬ ì‹œì•¼ ë°–ì¸ íƒ€ì¼ (ì–´ë‘¡ê²Œ) */
        .dimmed { 
            color: #333333 !important; 
        }
        .dimmed.floor { color: #222222 !important; } 
        .dimmed.stairs { color: #005555 !important; } 
        .dimmed.item { color: #550055 !important; } /* ì–´ë‘ìš´ ì•„ì´í…œ */

        /* ì¸ë²¤í† ë¦¬ ìŠ¤íƒ€ì¼ */
        .inventory-slot {
            display: inline-block;
            padding: 0 0.5rem;
            border: 1px solid #333;
            margin-right: 0.25rem;
            font-weight: bold;
            min-width: 6rem;
            text-align: center;
        }
        
        /* ì»¤ìŠ¤í…€ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .modal {
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
        }
        .modal-content {
            border: 3px solid #00aa00;
            box-shadow: 0 0 15px #00aa00;
            background-color: #111;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <!-- ë©”ì¸ ê²Œì„ ì»¨í…Œì´ë„ˆ -->
    <div class="game-area p-4 m-4 w-full max-w-6xl h-full max-h-[95vh] flex flex-row rounded-lg">

        <!-- ì¢Œì¸¡: ë§µ, ìƒíƒœ, ë¡œê·¸ -->
        <div class="flex-grow flex flex-col w-full md:w-3/4 pr-4">
            <!-- ìƒë‹¨ ìƒíƒœë°” -->
            <div class="p-2 border-b border-gray-700 mb-2 flex flex-wrap justify-between text-sm sm:text-base">
                <div class="flex flex-col sm:flex-row sm:space-x-4 mb-2 sm:mb-0 w-full sm:w-auto">
                    <span id="floor-display">Floor: 1</span>
                    <span id="player-level-display">P-Level: 1</span>
                    <span id="hp-display" class="text-red-500">HP: 20/20</span>
                    <span id="hunger-display" class="text-yellow-400">Hunger: 100%</span>
                    <span id="gold-display">Gold: 0</span>
                    <span id="time-display">Turn: 0</span>
                </div>
                 <!-- ìƒˆë¡œìš´ ëŠ¥ë ¥ì¹˜ í‘œì‹œ -->
                <div class="flex space-x-4">
                    <span id="damage-display">DMG: 1</span>
                    <span id="evasion-display">EVA: 0%</span>
                </div>
            </div>
            
            <!-- ì¸ë²¤í† ë¦¬ ë° ì •ìˆ˜ ì¹¸ -->
            <div id="inventory-display" class="p-2 border-b border-gray-700 mb-4 text-xs sm:text-sm overflow-x-auto whitespace-nowrap">
                <!-- ì¸ë²¤í† ë¦¬ ìŠ¬ë¡¯ ë° ì •ìˆ˜ í‘œì‹œ ì˜ì—­ -->
            </div>

            <!-- ë˜ì „ ë·°í¬íŠ¸ -->
            <div id="dungeon-viewport" class="flex-grow bg-black p-2 overflow-auto">
                <!-- ë˜ì „ ë§µì´ ì—¬ê¸°ì— ë¡œë“œë©ë‹ˆë‹¤. -->
            </div>

            <!-- í•˜ë‹¨ ë©”ì‹œì§€ ë¡œê·¸ -->
            <div id="message-log" class="mt-4 p-2 h-16 border-t border-gray-700 text-xs sm:text-sm overflow-y-auto">
                <span class="text-green-400">[SYSTEM]</span> ë˜ì „ ìƒì„± ì™„ë£Œ. WASD/í™”ì‚´í‘œë¡œ ì´ë™, 1~5 í‚¤ë¡œ ì•„ì´í…œì„ ì‚¬ìš©í•˜ì„¸ìš”.
            </div>
        </div>

        <!-- ìš°ì¸¡: ëª…ì˜ˆì˜ ì „ë‹¹ (Hall of Fame) -->
        <div id="hall-of-fame-panel" class="w-full md:w-1/4 p-2 border-l border-gray-700 ml-4 hidden md:block overflow-y-auto">
            <h3 class="text-lg font-bold text-center text-yellow-500 mb-2 border-b border-gray-700 pb-1">ëª…ì˜ˆì˜ ì „ë‹¹ (Top 10)</h3>
            <div id="hall-of-fame-list" class="text-xs">
                <p class="text-gray-500 text-center">ë°ì´í„° ë¡œë“œ ì¤‘...</p>
            </div>
        </div>
    </div>

    <!-- ê²Œì„ ì˜¤ë²„/ì ìˆ˜ ê¸°ë¡ ëª¨ë‹¬ (Custom Modal) -->
    <div id="score-modal" class="modal fixed inset-0 flex items-center justify-center hidden">
        <div class="modal-content p-6 rounded-lg w-full max-w-md">
            <h2 id="modal-title" class="text-xl font-bold text-red-500 mb-4 text-center">GAME OVER</h2>
            <p id="modal-message" class="mb-4 text-center"></p>
            <div id="modal-input-area" class="hidden">
                <label for="player-name" class="block mb-2 text-sm text-green-400">í”Œë ˆì´ì–´ ì´ë¦„ (3~10ì):</label>
                <input type="text" id="player-name" class="w-full p-2 mb-4 bg-gray-800 border border-green-700 text-white rounded focus:outline-none focus:border-green-400" maxlength="10">
            </div>
            <div id="modal-buttons" class="flex justify-around">
                <button id="modal-confirm" class="bg-green-600 hover:bg-green-700 text-black font-bold py-2 px-4 rounded-full transition-colors hidden" disabled>ê¸°ë¡í•˜ê¸°</button>
                <button id="modal-cancel" class="bg-red-600 hover:bg-red-700 text-black font-bold py-2 px-4 rounded-full transition-colors">ë‹«ê¸°</button>
            </div>
        </div>
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, orderBy, limit, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables
        let app;
        let db;
        let auth;
        let userId;

        // Firebase configuration and environment variables (MANDATORY)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // ë˜ì „ ìƒìˆ˜ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
        const MAP_WIDTH = 60; 
        const MAP_HEIGHT = 30;
        const MAX_ROOMS = 12; 
        const MIN_ROOM_SIZE = 5;
        const MAX_ROOM_SIZE = 12; 
        const FOV_RADIUS = 7; 

        // íƒ€ì¼ ì •ì˜
        const TILE_WALL = '#';
        const TILE_FLOOR = '.';
        const TILE_PLAYER = '@';
        const TILE_STAIRS = '>';
        const TILE_ITEM = '%'; 
        
        // ì‹œì•¼ ìƒìˆ˜
        const VISIBILITY_UNEXPLORED = 0; 
        const VISIBILITY_SEEN = 1;      
        const VISIBILITY_VISIBLE = 2;   
        
        // ì¸ë²¤í† ë¦¬ ë° ë°°ê³ í”” ìƒìˆ˜
        const INVENTORY_SIZE = 5;
        const MAX_HUNGER = 100;
        const HUNGER_DECAY_CHANCE = 0.15; 

        // ëª¬ìŠ¤í„° ì‹¬ë³¼ ì •ì˜ ë° ê¸°ë³¸ í…œí”Œë¦¿ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
        const MONSTER_TEMPLATES = {
            'S': { name: 'Slime', hp: 5, damage: 1, symbol: 'S' },
            'H': { name: 'Husk', hp: 5, damage: 1, symbol: 'H' },
            'Y': { name: 'Yeti', hp: 5, damage: 1, symbol: 'Y' },
            'P': { name: 'Piranha', hp: 5, damage: 1, symbol: 'P' },
            'O': { name: 'Ogre', hp: 5, damage: 1, symbol: 'O' }
        };
        const MONSTER_SYMBOLS = Object.keys(MONSTER_TEMPLATES);

        // ì•„ì´í…œ ë° ì •ìˆ˜ ì •ì˜ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
        const ITEM_DEFINITIONS = [
            { id: 'bandage', symbol: TILE_ITEM, name: 'ë¶•ëŒ€', type: 'consumable', use: 'turn-heal', effectValue: 1, turns: 2 },
            { id: 'food', symbol: TILE_ITEM, name: 'ìŒì‹', type: 'consumable', use: 'instant-hunger', effectValue: 50 },
        ];
        
        // ì •ìˆ˜ ì •ì˜ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
        const ESSENCE_DEFINITIONS = {
            'S': { name: 'í˜ì˜ ì •ìˆ˜', stat: 'damage', value: 1, dropChance: 0.25, color: 'text-yellow-500' },
            'H': { name: 'ì²´ë ¥ì˜ ì •ìˆ˜', stat: 'maxHp', value: 5, dropChance: 0.25, color: 'text-green-500' },
            'Y': { name: 'íšŒí”¼ì˜ ì •ìˆ˜', stat: 'evasion', value: 5, dropChance: 0.25, color: 'text-cyan-500' } 
        };


        // ì „ì—­ ìƒíƒœ ë³€ìˆ˜ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
        let gameState = {
            mapWidth: MAP_WIDTH, 
            mapHeight: MAP_HEIGHT, 
            playerX: 0,
            playerY: 0,
            map: [], 
            visibilityMap: [], 
            turn: 0,
            rooms: [], 
            currentLevel: 1, // í˜„ì¬ ì¸µ ë ˆë²¨
            isBossFloor: false, // í˜„ì¬ ì¸µì´ ë³´ìŠ¤ ì¸µì¸ì§€
            isBossDefeated: false, // í˜„ì¬ ë³´ìŠ¤ ì¸µì—ì„œ ë³´ìŠ¤ë¥¼ ì¡ì•˜ëŠ”ì§€
            player: { 
                hp: 20,
                maxHp: 20,
                gold: 0,
                level: 1,       // í”Œë ˆì´ì–´ ì „íˆ¬ ë ˆë²¨ (ëª¬ìŠ¤í„° ì²˜ì¹˜ë¡œ ìƒìŠ¹)
                damage: 1,      
                evasion: 0,     
                statusEffects: [], 
            },
            hunger: MAX_HUNGER,         
            inventory: new Array(INVENTORY_SIZE).fill(null), 
            essences: { damage: 0, maxHp: 0, evasion: 0 }, 
            items: [],           
            monsters: [],        
        };

        // DOM ìš”ì†Œ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
        const dungeonViewport = document.getElementById('dungeon-viewport');
        const INVENTORY_DISPLAY = document.getElementById('inventory-display');
        const STATUS_DISPLAY = {
            floor: document.getElementById('floor-display'), 
            playerLevel: document.getElementById('player-level-display'), 
            hp: document.getElementById('hp-display'),
            hunger: document.getElementById('hunger-display'),
            gold: document.getElementById('gold-display'),
            time: document.getElementById('time-display'),
            damage: document.getElementById('damage-display'),
            evasion: document.getElementById('evasion-display')
        };
        const scoreModal = document.getElementById('score-modal');
        const playerNameInput = document.getElementById('player-name');
        const modalConfirmBtn = document.getElementById('modal-confirm');
        const hallOfFameList = document.getElementById('hall-of-fame-list');


        /**
         * @function generateUUID
         */
        const generateUUID = () => crypto.randomUUID();

        /**
         * @function getRandomInt
         */
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        /**
         * @function logMessage
         */
        function logMessage(text, color = 'text-white') {
            const log = document.getElementById('message-log');
            const messageElement = document.createElement('div');
            if (log.childElementCount > 50) {
                log.removeChild(log.firstChild);
            }
            messageElement.innerHTML = `<span class="${color}">${text}</span>`;
            log.appendChild(messageElement);
            log.scrollTop = log.scrollHeight;
        }
        
        /**
         * @function getTile / setTile
         */
        function getTile(x, y) {
            if (y >= 0 && y < gameState.mapHeight && x >= 0 && x < gameState.mapWidth) {
                return gameState.map[y][x];
            }
            return TILE_WALL; 
        }

        function setTile(x, y, tile) {
            if (y >= 0 && y < gameState.mapHeight && x >= 0 && x < gameState.mapWidth) {
                gameState.map[y][x] = tile;
                return true;
            }
            return false;
        }

        /**
         * @function getMonsterBaseStats
         * @description ëª¬ìŠ¤í„°ì˜ ê¸°ë³¸ ìŠ¤íƒ¯ì„ ê³„ì‚°í•©ë‹ˆë‹¤. (3ì¸µë§ˆë‹¤ ê³µê²©ë ¥ +1)
         */
        function getMonsterBaseStats(currentLevel) {
            // HP: 1ì¸µ 5, 2ì¸µë§ˆë‹¤ +1
            const baseHP = 5 + Math.floor((currentLevel - 1) / 2); 
            
            // Damage: 1ì¸µ 1, 3ì¸µë§ˆë‹¤ +1 (ìˆ˜ì •ëœ ë¡œì§ ë°˜ì˜)
            const baseDamage = 1 + Math.floor(currentLevel / 3); 
            
            return { hp: baseHP, damage: baseDamage };
        }

        /**
         * @function getMonsterStats
         */
        function getMonsterStats(templateSymbol, isBoss) {
            const template = MONSTER_TEMPLATES[templateSymbol];
            const { hp: baseHP, damage: baseDamage } = getMonsterBaseStats(gameState.currentLevel);

            let finalHP = baseHP;
            let finalDamage = baseDamage;
            let finalName = template.name;
            let isBossType = isBoss;

            if (isBoss) {
                // ë³´ìŠ¤ ë³´ë„ˆìŠ¤: HP +5, Damage +2
                finalHP += 5;
                finalDamage += 2;
                finalName = `[BOSS] ë¶‰ê²Œ ë¹›ë‚˜ëŠ” ${template.name}`;
            }

            return { 
                ...template,
                name: finalName,
                hp: finalHP, 
                maxHp: finalHP, 
                damage: finalDamage,
                isBoss: isBossType 
            };
        }

        /**
         * @function placeEntity
         */
        function placeEntity(entityList, entityData, tileSymbol, count = 1) {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            const floorTiles = [];
            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (getTile(x, y) === TILE_FLOOR) {
                        const isOccupied = entityList.some(e => e.x === x && e.y === y);
                        // í”Œë ˆì´ì–´ë‚˜ ê³„ë‹¨ì´ ìˆëŠ” ê³³ì—ëŠ” ë°°ì¹˜í•˜ì§€ ì•ŠìŒ (ê³„ë‹¨ì€ ë‚˜ì¤‘ì— ë°”ë‹¥ìœ¼ë¡œ ì¸ì‹ë¨)
                        if (!isOccupied && (x !== gameState.playerX || y !== gameState.playerY) && getTile(x, y) !== TILE_STAIRS) {
                            floorTiles.push({ x, y });
                        }
                    }
                }
            }

            for (let i = 0; i < count && floorTiles.length > 0; i++) {
                const index = getRandomInt(0, floorTiles.length - 1);
                const pos = floorTiles[index];
                
                let newEntity = { x: pos.x, y: pos.y, id: generateUUID(), data: entityData };
                
                if (tileSymbol !== TILE_ITEM) {
                    newEntity.data = JSON.parse(JSON.stringify(entityData));
                }

                entityList.push(newEntity);
                
                floorTiles.splice(index, 1); 
            }
        }
        
        /**
         * ë˜ì „ ìƒì„± ê´€ë ¨ í•¨ìˆ˜ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
         */
        function createRoom(room) {
            for (let y = room.y; y < room.y + room.h; y++) {
                for (let x = room.x; x < room.x + room.w; x++) {
                    setTile(x, y, TILE_FLOOR);
                }
            }
        }
        
        function createCorridor(startRoom, endRoom) {
            const startX = startRoom.x + Math.floor(startRoom.w / 2);
            const startY = startRoom.y + Math.floor(startRoom.h / 2);
            const endX = endRoom.x + Math.floor(endRoom.w / 2);
            const endY = endRoom.y + Math.floor(endRoom.h / 2);

            let x = startX;
            let y = startY;

            while (x !== endX) {
                setTile(x, y, TILE_FLOOR);
                x += (x < endX ? 1 : -1);
            }

            while (y !== endY) {
                setTile(x, y, TILE_FLOOR);
                y += (y < endY ? 1 : -1);
            }
        }

        function generateDungeon() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            gameState.map = [];
            gameState.visibilityMap = []; 
            gameState.rooms = [];
            gameState.items = []; 
            gameState.monsters = []; 

            // 5ì¸µë§ˆë‹¤ ë³´ìŠ¤ ì¸µ ì„¤ì •
            gameState.isBossFloor = (gameState.currentLevel % 5 === 0);
            gameState.isBossDefeated = false; // ìƒˆ ì¸µì—ì„œëŠ” ë³´ìŠ¤ ë¯¸ì²˜ì¹˜ ìƒíƒœë¡œ ì‹œì‘


            for (let y = 0; y < gameState.mapHeight; y++) {
                gameState.map.push(new Array(gameState.mapWidth).fill(TILE_WALL));
                gameState.visibilityMap.push(new Array(gameState.mapWidth).fill(VISIBILITY_UNEXPLORED));
            }

            // ë°© ìƒì„± 
            for (let i = 0; i < 100; i++) { 
                if (gameState.rooms.length >= MAX_ROOMS) break;
                const w = getRandomInt(MIN_ROOM_SIZE, MAX_ROOM_SIZE);
                const h = getRandomInt(MIN_ROOM_SIZE, MAX_ROOM_SIZE);
                const x = getRandomInt(1, gameState.mapWidth - w - 1);
                const y = getRandomInt(1, gameState.mapHeight - h - 1);
                const newRoom = { x, y, w, h };
                let overlaps = false;
                for (const existingRoom of gameState.rooms) {
                    if (x < existingRoom.x + existingRoom.w + 1 &&
                        x + w > existingRoom.x - 1 &&
                        y < existingRoom.y + existingRoom.h + 1 &&
                        y + h > existingRoom.y - 1) {
                        overlaps = true;
                        break;
                    }
                }
                if (!overlaps) {
                    createRoom(newRoom);
                    gameState.rooms.push(newRoom);
                }
            }
            
            // ë°© ì—°ê²° 
            for (let i = 1; i < gameState.rooms.length; i++) {
                createCorridor(gameState.rooms[i - 1], gameState.rooms[i]);
            }

            // í”Œë ˆì´ì–´ì™€ ê³„ë‹¨ ë°°ì¹˜
            const floorTiles = [];
            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (getTile(x, y) === TILE_FLOOR) {
                        floorTiles.push({ x, y });
                    }
                }
            }

            if (floorTiles.length > 0) {
                const playerPosIndex = getRandomInt(0, floorTiles.length - 1);
                const playerPos = floorTiles[playerPosIndex];
                gameState.playerX = playerPos.x;
                gameState.playerY = playerPos.y;
                floorTiles.splice(playerPosIndex, 1); 

                if (floorTiles.length > 0) {
                    const stairsPos = floorTiles[getRandomInt(0, floorTiles.length - 1)];
                    setTile(stairsPos.x, stairsPos.y, TILE_STAIRS);
                }
            } else {
                logMessage("[ERROR] ë˜ì „ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", 'text-red-500');
                gameState.playerX = 5;
                gameState.playerY = 5;
            }

            // ëª¬ìŠ¤í„° ë° ì•„ì´í…œ ë°°ì¹˜
            const entityCount = Math.floor(gameState.rooms.length * 0.7);

            // ì•„ì´í…œ ë°°ì¹˜ 
            for (let i = 0; i < entityCount; i++) {
                const itemType = (i % 2 === 0) ? ITEM_DEFINITIONS.find(d => d.id === 'food') : ITEM_DEFINITIONS.find(d => d.id === 'bandage');
                placeEntity(gameState.items, itemType, TILE_ITEM, 1);
            }
            
            // ëª¬ìŠ¤í„° ë°°ì¹˜ (ë³´ìŠ¤ ë¡œì§ ì ìš©)
            if (gameState.isBossFloor) {
                // ë³´ìŠ¤ ì¸µ: 1ë§ˆë¦¬ì˜ ë³´ìŠ¤ë§Œ ë°°ì¹˜
                const symbol = MONSTER_SYMBOLS[getRandomInt(0, MONSTER_SYMBOLS.length - 1)];
                const bossStats = getMonsterStats(symbol, true);
                placeEntity(gameState.monsters, bossStats, symbol, 1);
                logMessage(`[WARNING] ğŸš¨ ${gameState.currentLevel}ì¸µì˜ ë³´ìŠ¤ ${bossStats.name}ê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!`, 'text-red-500 font-bold');
            } else {
                // ì¼ë°˜ ì¸µ: ì¼ë°˜ ëª¬ìŠ¤í„° ë°°ì¹˜
                for (let i = 0; i < entityCount; i++) {
                    const symbol = MONSTER_SYMBOLS[getRandomInt(0, MONSTER_SYMBOLS.length - 1)];
                    const monsterStats = getMonsterStats(symbol, false);
                    placeEntity(gameState.monsters, monsterStats, symbol, 1);
                }
            }
        }


        /**
         * @function calculateFOV
         */
        function calculateFOV() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            const px = gameState.playerX;
            const py = gameState.playerY;
            const radius = FOV_RADIUS;
            const radiusSq = radius * radius;

            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (gameState.visibilityMap[y][x] === VISIBILITY_VISIBLE) {
                        gameState.visibilityMap[y][x] = VISIBILITY_SEEN;
                    }
                }
            }

            for (let y = py - radius; y <= py + radius; y++) {
                for (let x = px - radius; x <= px + radius; x++) {
                    if (y >= 0 && y < gameState.mapHeight && x >= 0 && x < gameState.mapWidth) {
                        const dx = x - px;
                        const dy = y - py;
                        if (dx * dx + dy * dy <= radiusSq) { 
                            gameState.visibilityMap[y][x] = VISIBILITY_VISIBLE;
                        }
                    }
                }
            }
        }


        /**
         * @function renderDungeon
         */
        function renderDungeon() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            let mapHTML = '';
            const px = gameState.playerX;
            const py = gameState.playerY;

            // ëª¬ìŠ¤í„°ì™€ ì•„ì´í…œ ìœ„ì¹˜ë¥¼ ì‰½ê²Œ ì°¾ê¸° ìœ„í•œ ë§µ ìƒì„±
            const entityMap = {};
            gameState.items.forEach(item => entityMap[`${item.x},${item.y}`] = item.data.symbol);
            gameState.monsters.forEach(monster => entityMap[`${monster.x},${monster.y}`] = monster); 

            for (let y = 0; y < gameState.mapHeight; y++) {
                let line = '';
                for (let x = 0; x < gameState.mapWidth; x++) {
                    const visibility = gameState.visibilityMap[y][x];
                    let tile = gameState.map[y][x];
                    let tileClass = '';
                    let isPlayer = (x === px && y === py);
                    const entity = entityMap[`${x},${y}`];
                    const entitySymbol = entity ? (entity.data ? entity.data.symbol : entity) : null;

                    if (visibility === VISIBILITY_UNEXPLORED) {
                        line += ' '; 
                        continue;
                    }

                    // 1. íƒ€ì¼ ì‹¬ë³¼ ê²°ì • (í”Œë ˆì´ì–´ > ëª¬ìŠ¤í„° > ì•„ì´í…œ > ë§µ íƒ€ì¼ ìˆœìœ¼ë¡œ ìš°ì„ ìˆœìœ„)
                    if (isPlayer) {
                        tile = TILE_PLAYER;
                        tileClass = 'player';
                    } else if (entitySymbol) {
                        tile = entitySymbol;
                        if (tile === TILE_ITEM) {
                            tileClass = 'item';
                        } else if (MONSTER_SYMBOLS.includes(tile)) {
                            tileClass = `monster-${tile}`;
                            // ë³´ìŠ¤ ëª¬ìŠ¤í„° ìŠ¤íƒ€ì¼ë§ ì¶”ê°€
                            if (entity.data.isBoss) {
                                tileClass += ' boss-glow'; 
                            }
                        }
                    } else {
                        // ë§µ íƒ€ì¼
                        switch(tile) {
                            case TILE_WALL: tileClass = 'wall'; break;
                            case TILE_FLOOR: tileClass = 'floor'; break;
                            case TILE_STAIRS: tileClass = 'stairs'; break;
                            default: tileClass = '';
                        }
                    }

                    if (visibility === VISIBILITY_SEEN) {
                        tileClass += ' dimmed';
                    }
                    
                    line += `<span class="${tileClass}">${tile}</span>`;
                }
                mapHTML += line + '\n';
            }
            dungeonViewport.innerHTML = mapHTML.trim();
        }
        
        /**
         * @function updateStatus
         */
        function updateStatus() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            const player = gameState.player;
            const essences = gameState.essences;

            STATUS_DISPLAY.floor.textContent = `Floor: ${gameState.currentLevel}`;
            STATUS_DISPLAY.playerLevel.textContent = `P-Level: ${player.level}`; 
            STATUS_DISPLAY.time.textContent = `Turn: ${gameState.turn}`;
            STATUS_DISPLAY.gold.textContent = `Gold: ${player.gold}`;
            
            // HP í‘œì‹œ (ì •ìˆ˜ íš¨ê³¼ ë°˜ì˜)
            const currentMaxHp = player.maxHp + essences.maxHp;
            STATUS_DISPLAY.hp.textContent = `HP: ${player.hp}/${currentMaxHp}`;
            
            // ë°°ê³ í”” í‘œì‹œ
            const hungerColor = gameState.hunger > 30 ? 'text-yellow-400' : 'text-red-500';
            STATUS_DISPLAY.hunger.innerHTML = `<span class="${hungerColor}">Hunger: ${gameState.hunger}%</span>`;

            // ëŠ¥ë ¥ì¹˜ í‘œì‹œ (ì •ìˆ˜ì™€ í”Œë ˆì´ì–´ ë ˆë²¨ ë°ë¯¸ì§€ ë°˜ì˜)
            const totalDamage = player.damage + essences.damage; 
            STATUS_DISPLAY.damage.textContent = `DMG: ${totalDamage}`;
            STATUS_DISPLAY.evasion.textContent = `EVA: ${player.evasion + essences.evasion}%`;

            // ì¸ë²¤í† ë¦¬ ë° ì •ìˆ˜ í‘œì‹œ
            let invHTML = 'ì¸ë²¤í† ë¦¬: ';
            gameState.inventory.forEach((item, index) => {
                const slotNumber = index + 1;
                const itemName = item ? item.name : 'ë¹ˆ ê³µê°„';
                const itemColor = item ? (item.id === 'food' ? 'text-yellow-300' : 'text-lime-300') : 'text-gray-500';
                invHTML += `<span class="inventory-slot ${itemColor}">${slotNumber}. [${itemName}]</span>`;
            });

            invHTML += ' | ì •ìˆ˜: ';
            invHTML += `<span class="${ESSENCE_DEFINITIONS.S.color}">í˜: ${essences.damage}</span>, `;
            invHTML += `<span class="${ESSENCE_DEFINITIONS.H.color}">ì²´ë ¥: ${essences.maxHp}</span>, `;
            invHTML += `<span class="${ESSENCE_DEFINITIONS.Y.color}">íšŒí”¼: ${essences.evasion}</span>`;

            INVENTORY_DISPLAY.innerHTML = invHTML;
        }

        /**
         * @function addItem
         */
        function addItem(item) {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            const emptySlot = gameState.inventory.findIndex(slot => slot === null);
            if (emptySlot !== -1) {
                gameState.inventory[emptySlot] = item;
                logMessage(`[ITEM] ${item.name}ì„(ë¥¼) ì¸ë²¤í† ë¦¬ ${emptySlot + 1}ë²ˆ ìŠ¬ë¡¯ì— íšë“í–ˆìŠµë‹ˆë‹¤.`, 'text-lime-400');
                return true;
            } else {
                logMessage("[ITEM] ì¸ë²¤í† ë¦¬ê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤. ì•„ì´í…œì„ ë†“ì¹  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", 'text-red-400');
                return false;
            }
        }
        
        /**
         * @function useItem
         */
        function useItem(slotIndex) {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            const item = gameState.inventory[slotIndex];

            if (!item) {
                logMessage(`[INVENTORY] ${slotIndex + 1}ë²ˆ ìŠ¬ë¡¯ì€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.`, 'text-gray-500');
                return;
            }

            logMessage(`[INVENTORY] ${item.name}ì„(ë¥¼) ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.`, 'text-lime-400');
            
            let used = false;
            const player = gameState.player;
            const currentMaxHp = player.maxHp + gameState.essences.maxHp;

            if (item.type === 'consumable') {
                if (item.use === 'turn-heal') {
                    player.statusEffects.push({ 
                        name: item.name, 
                        remainingTurns: item.turns, 
                        effect: 'heal',
                        value: item.effectValue 
                    });
                    logMessage(`[EFFECT] ${item.turns}í„´ ë™ì•ˆ ë§¤ í„´ HP ${item.effectValue}ì”© íšŒë³µí•©ë‹ˆë‹¤.`, 'text-green-500');
                    used = true;
                } else if (item.use === 'instant-hunger') {
                    gameState.hunger = Math.min(MAX_HUNGER, gameState.hunger + item.effectValue);
                    logMessage(`[HUNGER] ë°°ê³ í”” ${item.effectValue}% íšŒë³µ!`, 'text-yellow-300');
                    used = true;
                }
            } 
            
            if (used) {
                gameState.inventory[slotIndex] = null; 
                updateStatus();
                gameState.turn++; 
                runGameTurn();
            }
        }


        /**
         * @function checkEssenceDrop
         */
        function checkEssenceDrop(monster) {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            const symbol = monster.data.symbol;
            const essenceDef = ESSENCE_DEFINITIONS[symbol];

            if (essenceDef && Math.random() < essenceDef.dropChance) { 
                const statKey = essenceDef.stat;
                gameState.essences[statKey] += essenceDef.value;
                logMessage(`[DROP] ${monster.data.name} ì²˜ì¹˜ í›„ ${essenceDef.name}ì„(ë¥¼) íšë“í–ˆìŠµë‹ˆë‹¤! (${essenceDef.stat} +${essenceDef.value})`, essenceDef.color);
            }
        }

        /**
         * @function tryLevelUp
         */
        function tryLevelUp() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            if (Math.random() < 0.25) { 
                const player = gameState.player;
                const currentMaxHp = player.maxHp + gameState.essences.maxHp;

                player.level++;
                player.damage += 1; // ê¸°ë³¸ ê³µê²©ë ¥ 1 ìƒìŠ¹
                player.hp = currentMaxHp; // HP ì™„ì „ íšŒë³µ
                
                logMessage(`[LEVEL UP] ëª¬ìŠ¤í„° ì²˜ì¹˜ë¡œ ë ˆë²¨ì—… í–ˆìŠµë‹ˆë‹¤! (Lv ${player.level})`, 'text-yellow-400 font-bold');
                logMessage(`[BONUS] HP ì™„ì „ íšŒë³µ ë° ê³µê²©ë ¥ +1 ìƒìŠ¹! (DMG: ${player.damage + gameState.essences.damage})`, 'text-green-400');
            }
        }
        
        /**
         * @function checkCombat
         */
        function checkCombat(x, y) {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€, ì‚¬ë§ ì²´í¬ í›„ handleGameOver í˜¸ì¶œ
            const monsterIndex = gameState.monsters.findIndex(m => m.x === x && m.y === y);

            if (monsterIndex !== -1) {
                const monster = gameState.monsters[monsterIndex];
                const player = gameState.player;
                
                const totalPlayerDamage = player.damage + gameState.essences.damage;
                
                logMessage(`[COMBAT] ${monster.data.name}(HP: ${monster.data.hp})ì„(ë¥¼) ê³µê²©! (DMG: ${totalPlayerDamage})`, 'text-orange-500');
                
                if (Math.random() < 0.5) { 
                     monster.data.hp -= totalPlayerDamage;
                     logMessage(`[HIT] ëª…ì¤‘! ${totalPlayerDamage} ë°ë¯¸ì§€ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤. ëª¬ìŠ¤í„° ì”ì—¬ HP: ${Math.max(0, monster.data.hp)}`);
                } else {
                     logMessage(`[MISS] ê³µê²©ì´ ë¹—ë‚˜ê°”ìŠµë‹ˆë‹¤.`, 'text-gray-500');
                }
                
                if (monster.data.hp <= 0) {
                    logMessage(`[VICTORY] ${monster.data.name}ì„(ë¥¼) ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤.`, 'text-green-500');
                    
                    if (monster.data.isBoss) {
                        gameState.isBossDefeated = true;
                        logMessage("[BOSS] ë³´ìŠ¤ë¥¼ ì“°ëŸ¬ëœ¨ë ¤ ë‹¤ìŒ ì¸µìœ¼ë¡œ ê°€ëŠ” ê¸¸ì´ ì—´ë ¸ìŠµë‹ˆë‹¤!", 'text-green-500 font-bold');
                    }
                    
                    checkEssenceDrop(monster); 
                    tryLevelUp(); 
                    gameState.monsters.splice(monsterIndex, 1); 

                    return true; 
                }

                if (Math.random() < 0.5) {
                    const monsterDamage = monster.data.damage; 
                    gameState.player.hp = Math.max(0, gameState.player.hp - monsterDamage);
                    logMessage(`[ATTACKED] ${monster.data.name}ì˜ ë°˜ê²©! ${monsterDamage} ë°ë¯¸ì§€ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤. (HP: ${gameState.player.hp})`, 'text-red-600');
                    if (gameState.player.hp <= 0) {
                        handleGameOver("[GAME OVER] ëª¬ìŠ¤í„°ì˜ ë°˜ê²©ìœ¼ë¡œ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤.");
                    }
                } else {
                    logMessage(`[MISS] ${monster.data.name}ì˜ ê³µê²©ì´ ë¹—ë‚˜ê°”ìŠµë‹ˆë‹¤. (ëª¬ìŠ¤í„° HP: ${monster.data.hp})`, 'text-gray-500');
                }

                return false;
            }
            return false;
        }
        
        /**
         * @function canMove
         */
        function canMove(x, y, currentMonsterId = null) {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            if (x < 0 || x >= gameState.mapWidth || y < 0 || y >= gameState.mapHeight) {
                return false; 
            }
            if (getTile(x, y) === TILE_WALL) {
                return false; 
            }

            if (getTile(x, y) === TILE_STAIRS) {
                return true;
            }
            
            if (gameState.monsters.some(m => m.id !== currentMonsterId && m.x === x && m.y === y)) {
                return false;
            }
            
            return true; 
        }

        /**
         * @function moveMonsters
         */
        function moveMonsters() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€, ì‚¬ë§ ì²´í¬ í›„ handleGameOver í˜¸ì¶œ
            const px = gameState.playerX;
            const py = gameState.playerY;

            const currentMonsters = [...gameState.monsters]; 

            currentMonsters.forEach(monster => {
                const mx = monster.x;
                const my = monster.y;
                
                let finalDx = 0;
                let finalDy = 0;
                let isChasing = gameState.visibilityMap[my][mx] === VISIBILITY_VISIBLE; 

                if (isChasing) {
                    const targetDx = mx < px ? 1 : (mx > px ? -1 : 0);
                    const targetDy = my < py ? 1 : (my > py ? -1 : 0);

                    if (Math.abs(mx - px) >= Math.abs(my - py)) {
                        if (targetDx !== 0 && (canMove(mx + targetDx, my, monster.id) || (mx + targetDx === px && my === py))) {
                            finalDx = targetDx;
                        } else if (targetDy !== 0 && (canMove(mx, my + targetDy, monster.id) || (mx === px && my + targetDy === py))) {
                            finalDy = targetDy;
                        }
                    } else {
                        if (targetDy !== 0 && (canMove(mx, my + targetDy, monster.id) || (mx === px && my + targetDy === py))) {
                            finalDy = targetDy;
                        } else if (targetDx !== 0 && (canMove(mx + targetDx, my, monster.id) || (mx + targetDx === px && my + targetDy === py))) {
                            finalDx = targetDx;
                        }
                    }
                } 
                
                if (!isChasing || (finalDx === 0 && finalDy === 0)) {
                    const randomMoves = [{dx: 0, dy: 1}, {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 0}]; 
                    const {dx, dy} = randomMoves[getRandomInt(0, randomMoves.length - 1)];
                    
                    if (canMove(mx + dx, my + dy, monster.id)) {
                         finalDx = dx;
                         finalDy = dy;
                    }
                }

                if (finalDx !== 0 || finalDy !== 0) {
                    const nextX = mx + finalDx;
                    const nextY = my + finalDy;

                    if (nextX === px && nextY === py) {
                        if (Math.random() < 0.5) {
                            const monsterDamage = monster.data.damage; 
                            const currentMaxHp = gameState.player.maxHp + gameState.essences.maxHp;
                            gameState.player.hp = Math.max(0, gameState.player.hp - monsterDamage);
                            logMessage(`[ATTACKED] ${monster.data.name}ì˜ ê³µê²©! ${monsterDamage} ë°ë¯¸ì§€ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤. (HP: ${gameState.player.hp}/${currentMaxHp})`, 'text-red-600');
                        } else {
                            logMessage(`[MISS] ${monster.data.name}ì˜ ê³µê²©ì´ ë¹—ë‚˜ê°”ìŠµë‹ˆë‹¤.`, 'text-gray-500');
                        }
                    } else {
                        monster.x = nextX;
                        monster.y = nextY;
                    }
                }
            });
            
            if (gameState.player.hp <= 0) {
                handleGameOver("[GAME OVER] ëª¬ìŠ¤í„°ì˜ ê³µê²©ìœ¼ë¡œ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤.");
            }
        }


        /**
         * @function applyStatusEffects
         */
        function applyStatusEffects() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€, ì‚¬ë§ ì²´í¬ í›„ handleGameOver í˜¸ì¶œ
            const player = gameState.player;
            const currentMaxHp = player.maxHp + gameState.essences.maxHp;

            // 1. ìƒíƒœ íš¨ê³¼ ì ìš© ë° ê°ì†Œ
            player.statusEffects = player.statusEffects.filter(effect => {
                if (effect.effect === 'heal') {
                    if (player.hp < currentMaxHp) {
                         player.hp = Math.min(currentMaxHp, player.hp + effect.value);
                         logMessage(`[HEAL] ${effect.name} íš¨ê³¼ë¡œ HP ${effect.value} íšŒë³µ.`, 'text-green-500');
                    }
                }

                effect.remainingTurns--;
                if (effect.remainingTurns > 0) {
                    return true;
                } else {
                    logMessage(`[EFFECT] ${effect.name} íš¨ê³¼ê°€ ëë‚¬ìŠµë‹ˆë‹¤.`, 'text-gray-500');
                    return false;
                }
            });

            // 2. ë°°ê³ í”” ê°ì†Œ ì²˜ë¦¬ ë° í˜ë„í‹°
            if (gameState.hunger > 0) {
                if (Math.random() < HUNGER_DECAY_CHANCE) {
                    gameState.hunger = Math.max(0, gameState.hunger - 1);
                    if (gameState.hunger <= 30 && gameState.hunger > 0) {
                         logMessage("[HUNGER] ë°°ê°€ ê³ í”„ê¸° ì‹œì‘í•©ë‹ˆë‹¤.", 'text-red-400');
                    } else if (gameState.hunger === 0) {
                        logMessage("[HUNGER] ë°°ê³ í””ìœ¼ë¡œ ê³ í†µë°›ê¸° ì‹œì‘í•©ë‹ˆë‹¤!", 'text-red-500');
                    }
                }
            } else if (gameState.hunger === 0) {
                if (player.hp > 0) {
                    player.hp = Math.max(0, player.hp - 1);
                    logMessage("[DAMAGE] ë°°ê³ í”” ë•Œë¬¸ì— HPê°€ 1 ê°ì†Œí–ˆìŠµë‹ˆë‹¤.", 'text-red-500');
                }
            }

            // 3. ì‚¬ë§ ì²´í¬
            if (player.hp <= 0) {
                handleGameOver("[GAME OVER] ë‹¹ì‹ ì€ ë˜ì „ì—ì„œ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤.");
            }
        }

        // ------------------------------------
        // ëª…ì˜ˆì˜ ì „ë‹¹ (Hall of Fame) ê´€ë ¨ í•¨ìˆ˜
        // ------------------------------------
        
        /**
         * @function saveScore
         * @description Firestoreì— ê²Œì„ ì ìˆ˜ ê¸°ë¡ì„ ì €ì¥í•©ë‹ˆë‹¤.
         */
        async function saveScore(playerName) {
            if (!db || !userId) {
                logMessage("[ERROR] ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì˜¤ë¥˜: ì ìˆ˜ë¥¼ ê¸°ë¡í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", 'text-red-500');
                return;
            }

            const scoreData = {
                name: playerName,
                level: gameState.currentLevel,
                turn: gameState.turn,
                playerLevel: gameState.player.level,
                gold: gameState.player.gold,
                userId: userId,
                // ì •ìˆ˜ (Essences)ëŠ” JSON ë¬¸ìì—´ë¡œ ì €ì¥í•˜ì—¬ ë°ì´í„° ë¬´ê²°ì„±ì„ ìœ ì§€
                essences: JSON.stringify(gameState.essences), 
                date: serverTimestamp(),
            };

            try {
                const hallOfFameCollection = collection(db, `artifacts/${appId}/public/data/hall_of_fame`);
                await addDoc(hallOfFameCollection, scoreData);
                logMessage(`[HALL OF FAME] ${playerName}ë‹˜ì˜ ì ìˆ˜ê°€ ëª…ì˜ˆì˜ ì „ë‹¹ì— ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'text-yellow-500 font-bold');
                fetchHallOfFame(); // ê¸°ë¡ í›„ ëª©ë¡ ì—…ë°ì´íŠ¸
            } catch (error) {
                console.error("Error writing document: ", error);
                logMessage("[ERROR] ì ìˆ˜ ê¸°ë¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", 'text-red-500');
            }
        }
        
        /**
         * @function fetchHallOfFame
         * @description Firestoreì—ì„œ ëª…ì˜ˆì˜ ì „ë‹¹ ëª©ë¡ì„ ë¶ˆëŸ¬ì™€ UIë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
         */
        function fetchHallOfFame() {
            if (!db) return;

            try {
                const hallOfFameCollection = collection(db, `artifacts/${appId}/public/data/hall_of_fame`);
                
                // ìµœê³  ì¸µìˆ˜(level), í”Œë ˆì´ì–´ ë ˆë²¨(playerLevel), í„´ ìˆ˜(turn) ìˆœìœ¼ë¡œ ì •ë ¬
                const q = query(hallOfFameCollection, 
                                // levelì€ ë‚´ë¦¼ì°¨ìˆœ (ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ)
                                // playerLevelë„ ë‚´ë¦¼ì°¨ìˆœ
                                // turnì€ ì˜¤ë¦„ì°¨ìˆœ (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
                                orderBy("level", "desc"),
                                orderBy("playerLevel", "desc"),
                                orderBy("turn", "asc"),
                                limit(10));
                
                // onSnapshotìœ¼ë¡œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
                onSnapshot(q, (snapshot) => {
                    let listHTML = '';
                    snapshot.forEach((doc, index) => {
                        const data = doc.data();
                        
                        // Essences ë°ì´í„° íŒŒì‹±
                        let essencesData = { damage: 0, maxHp: 0, evasion: 0 };
                        try {
                            essencesData = JSON.parse(data.essences);
                        } catch (e) {
                            console.error("Essences parsing error:", e);
                        }

                        // ë‚ ì§œ í¬ë§·íŒ… (dateê°€ undefinedì¼ ê²½ìš°ë¥¼ ëŒ€ë¹„)
                        const dateStr = data.date ? new Date(data.date.seconds * 1000).toLocaleDateString('ko-KR') : 'ë‚ ì§œ ì—†ìŒ';

                        listHTML += `
                            <div class="border-b border-gray-900 pb-1 mb-1 ${index === 0 ? 'text-yellow-400 font-extrabold' : ''}">
                                <div class="flex justify-between">
                                    <span>#${index + 1}. ${data.name}</span>
                                    <span class="text-gray-500">${dateStr}</span>
                                </div>
                                <div>
                                    <span class="text-red-400">Lv ${data.playerLevel}</span> | 
                                    <span class="text-green-400">F${data.level}</span> | 
                                    <span class="text-cyan-400">${data.turn}í„´</span>
                                </div>
                                <div class="text-xs text-gray-400">
                                    í˜ ${essencesData.damage} | ì²´ë ¥ ${essencesData.maxHp} | íšŒí”¼ ${essencesData.evasion}
                                </div>
                            </div>
                        `;
                    });

                    if (listHTML === '') {
                        hallOfFameList.innerHTML = '<p class="text-gray-500 text-center">ì•„ì§ ê¸°ë¡ëœ ì ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                    } else {
                        hallOfFameList.innerHTML = listHTML;
                    }
                }, (error) => {
                    console.error("Error fetching Hall of Fame: ", error);
                    hallOfFameList.innerHTML = '<p class="text-red-500 text-center">ëª…ì˜ˆì˜ ì „ë‹¹ ë¡œë“œ ì˜¤ë¥˜.</p>';
                });

            } catch (error) {
                console.error("Firestore setup error:", error);
            }
        }
        
        /**
         * @function showGameOverModal
         * @description ê²Œì„ ì˜¤ë²„ í›„ ì ìˆ˜ ê¸°ë¡ ì—¬ë¶€ë¥¼ ë¬»ëŠ” ëª¨ë‹¬ì„ í‘œì‹œí•©ë‹ˆë‹¤.
         */
        function showGameOverModal(canRecord) {
            const titleEl = document.getElementById('modal-title');
            const messageEl = document.getElementById('modal-message');
            const inputAreaEl = document.getElementById('modal-input-area');
            
            scoreModal.classList.remove('hidden');

            if (canRecord) {
                titleEl.textContent = "ëª…ì˜ˆì˜ ì „ë‹¹ ê¸°ë¡";
                messageEl.innerHTML = `ìµœê³  ê¸°ë¡ ë‹¬ì„±! ${gameState.currentLevel}ì¸µì— ë„ë‹¬í•˜ì…¨ìŠµë‹ˆë‹¤.<br>ì ìˆ˜ë¥¼ ëª…ì˜ˆì˜ ì „ë‹¹ì— ê¸°ë¡í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                modalConfirmBtn.textContent = 'ê¸°ë¡í•˜ê¸°';
                modalConfirmBtn.classList.remove('hidden');
                inputAreaEl.classList.remove('hidden');

                // ì´ë¦„ ìœ íš¨ì„± ê²€ì‚¬ ë¦¬ìŠ¤ë„ˆ
                playerNameInput.value = ''; // ì´ˆê¸°í™”
                const validateName = () => {
                    const name = playerNameInput.value.trim();
                    if (name.length >= 3 && name.length <= 10) {
                        modalConfirmBtn.disabled = false;
                        modalConfirmBtn.classList.remove('bg-gray-500');
                        modalConfirmBtn.classList.add('bg-green-600');
                    } else {
                        modalConfirmBtn.disabled = true;
                        modalConfirmBtn.classList.remove('bg-green-600');
                        modalConfirmBtn.classList.add('bg-gray-500');
                    }
                };
                playerNameInput.oninput = validateName;
                validateName(); // ì´ˆê¸° ìƒíƒœ ê²€ì‚¬

                // í™•ì¸ ë²„íŠ¼ í´ë¦­ ë¦¬ìŠ¤ë„ˆ (ì ìˆ˜ ì €ì¥)
                modalConfirmBtn.onclick = () => {
                    const name = playerNameInput.value.trim();
                    if (name.length >= 3 && name.length <= 10) {
                        saveScore(name);
                        scoreModal.classList.add('hidden');
                        logMessage(`[SYSTEM] ëª…ì˜ˆì˜ ì „ë‹¹ ê¸°ë¡ì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.`, 'text-yellow-500');
                    } else {
                        logMessage("[SYSTEM] ì´ë¦„ì€ 3~10ìì—¬ì•¼ í•©ë‹ˆë‹¤.", 'text-red-500');
                    }
                };

            } else {
                // ê¸°ë¡ ë¶ˆê°€ëŠ¥ (20ì¸µ ë¯¸ë§Œ)
                titleEl.textContent = "GAME OVER";
                messageEl.textContent = `ë‹¹ì‹ ì€ ${gameState.currentLevel}ì¸µì—ì„œ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤.`;
                modalConfirmBtn.classList.add('hidden');
                inputAreaEl.classList.add('hidden');
                // ë‹«ê¸° ë²„íŠ¼ë§Œ ì‘ë™
            }
            
            // ë‹«ê¸° ë²„íŠ¼ í´ë¦­ ë¦¬ìŠ¤ë„ˆ (ëª¨ë‹¬ ë‹«ê¸°)
            document.getElementById('modal-cancel').onclick = () => {
                scoreModal.classList.add('hidden');
            };
        }
        
        /**
         * @function handleGameOver
         * @description ê²Œì„ ì˜¤ë²„ ë°œìƒ ì‹œ í˜¸ì¶œë©ë‹ˆë‹¤.
         */
        function handleGameOver(message) {
            logMessage(message, 'text-red-600 font-bold');
            document.removeEventListener('keydown', handleInput);

            // 20ì¸µ ì´ìƒì¼ ê²½ìš°ì—ë§Œ ê¸°ë¡ ê¸°íšŒ ì œê³µ
            const canRecord = gameState.currentLevel >= 20;

            showGameOverModal(canRecord);
        }

        /**
         * @function runGameTurn
         */
        function runGameTurn() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€ (ì‚¬ë§ ì²´í¬ëŠ” moveMonsters, applyStatusEffectsì—ì„œ ì²˜ë¦¬)
            if (gameState.player.hp <= 0) return; 

            gameState.turn++;
            
            moveMonsters();
            
            // moveMonstersì—ì„œ ì‚¬ë§ ì²˜ë¦¬ í›„ runGameTurnì´ í˜¸ì¶œë˜ì§€ ì•Šë„ë¡ ë°©ì–´
            if (gameState.player.hp > 0) { 
                applyStatusEffects(); 
            }
            
            updateStatus();
            calculateFOV(); 
            renderDungeon();
        }

        /**
         * @function handleInput
         */
        function handleInput(event) {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            if (gameState.player.hp <= 0) return; 

            let dx = 0;
            let dy = 0;
            
            // 1. ì´ë™ í‚¤ ì²˜ë¦¬ (WASD ë˜ëŠ” í™”ì‚´í‘œ)
            switch (event.key) {
                case 'w': case 'W': case 'ArrowUp': dy = -1; break;
                case 's': case 'S': case 'ArrowDown': dy = 1; break;
                case 'a': case 'A': case 'ArrowLeft': dx = -1; break;
                case 'd': case 'D': case 'ArrowRight': dx = 1; break;
                
                // 2. ì¸ë²¤í† ë¦¬ ì‚¬ìš© í‚¤ ì²˜ë¦¬ (1~5)
                case '1': useItem(0); return; 
                case '2': useItem(1); return;
                case '3': useItem(2); return;
                case '4': useItem(3); return;
                case '5': useItem(4); return;
                default: return; 
            }
            
            event.preventDefault(); 

            const newX = gameState.playerX + dx;
            const newY = gameState.playerY + dy;
            
            // ë§µ ê²½ê³„ ì²´í¬
            if (newX < 0 || newX >= gameState.mapWidth || newY < 0 || newY >= gameState.mapHeight) {
                return;
            }

            const targetTile = getTile(newX, newY);
            
            // 1. ë²½ ì¶©ëŒ
            if (targetTile === TILE_WALL) {
                return;
            }

            // 2. ëª¬ìŠ¤í„° ì¶©ëŒ (ì „íˆ¬)
            if (gameState.monsters.some(m => m.x === newX && m.y === newY)) {
                if (!checkCombat(newX, newY)) {
                    runGameTurn(); 
                    return;
                }
            }

            // 3. ì•„ì´í…œ íšë“
            const pickedItemIndex = gameState.items.findIndex(i => i.x === newX && i.y === newY);
            if (pickedItemIndex !== -1) {
                const item = gameState.items[pickedItemIndex].data;
                if (addItem(item)) {
                    gameState.items.splice(pickedItemIndex, 1);
                }
            }

            // 4. ê³„ë‹¨ ì²˜ë¦¬ (ë‹¤ìŒ ì¸µ ì´ë™) - ë³´ìŠ¤ ì¸µì¼ ê²½ìš° ì¡°ê±´ë¶€ ì´ë™
            if (targetTile === TILE_STAIRS) {
                if (gameState.isBossFloor && !gameState.isBossDefeated) {
                    logMessage("[BLOCKED] ë³´ìŠ¤ë¥¼ ì²˜ì¹˜í•´ì•¼ë§Œ ë‹¤ìŒ ì¸µìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!", 'text-red-500 font-bold');
                    return;
                }
                generateNewLevel();
                return; 
            }

            // 5. ì´ë™ ì‹¤í–‰
            gameState.playerX = newX;
            gameState.playerY = newY;
            
            runGameTurn();
        }
        
        /**
         * @function generateNewLevel
         */
        function generateNewLevel() {
            // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
            gameState.currentLevel++;
            gameState.turn = 0; 
            
            logMessage(`[MAP] ${gameState.currentLevel}ì¸µìœ¼ë¡œ ë‚´ë ¤ê°‘ë‹ˆë‹¤...`, 'text-yellow-400');
            
            // ëª¬ìŠ¤í„° ë° í”Œë ˆì´ì–´ ìŠ¤íƒ¯ ì—…ë°ì´íŠ¸ ë¡œê¹…
            const { hp: baseHP, damage: baseDamage } = getMonsterBaseStats(gameState.currentLevel);
            logMessage(`[INFO] ëª¬ìŠ¤í„° ê¸°ë³¸ ìŠ¤íƒ¯: HP ${baseHP}, DMG ${baseDamage}`, 'text-cyan-400');


            generateDungeon();
            
            calculateFOV(); 
            renderDungeon();
            updateStatus();

            logMessage(`[SYSTEM] ${gameState.currentLevel}ì¸µì— ë„ì°©í–ˆìŠµë‹ˆë‹¤.`, 'text-green-400');
        }


        /**
         * @function initializeFirebase
         * @description Firebaseë¥¼ ì´ˆê¸°í™”í•˜ê³  ì‚¬ìš©ì ì¸ì¦ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
         */
        async function initializeFirebase() {
            if (!firebaseConfig) {
                logMessage("[ERROR] Firebase ì„¤ì •ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ëª…ì˜ˆì˜ ì „ë‹¹ ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.", 'text-red-500');
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('Debug'); // ë¡œê·¸ ìˆ˜ì¤€ ì„¤ì •

                // ì¸ì¦ ì²˜ë¦¬
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // ì¸ì¦ ìƒíƒœ ë³€ê²½ ë¦¬ìŠ¤ë„ˆ
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        logMessage(`[DB] ì‚¬ìš©ì ì¸ì¦ ì™„ë£Œ: ${userId.substring(0, 8)}...`, 'text-cyan-400');
                        fetchHallOfFame(); // ì¸ì¦ í›„ ëª…ì˜ˆì˜ ì „ë‹¹ ë¡œë“œ
                    } else {
                        logMessage("[DB] ì‚¬ìš©ì ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", 'text-red-500');
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                logMessage(`[ERROR] Firebase ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`, 'text-red-500');
            }
        }


        /**
         * @function initializeGame
         */
        async function initializeGame() {
            logMessage("[SYSTEM] ê²Œì„ ì‹œì‘ ì¤€ë¹„ ì¤‘...", 'text-green-400');
            
            // 1. Firebase ì´ˆê¸°í™” ë° ì¸ì¦ ì‹œë„
            await initializeFirebase(); 
            
            // 2. ëª¬ìŠ¤í„° ìŠ¤íƒ¯ ë¡œê¹… ë° ë˜ì „ ìƒì„± (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
            const { hp: baseHP, damage: baseDamage } = getMonsterBaseStats(gameState.currentLevel);
            logMessage(`[INFO] ëª¬ìŠ¤í„° ê¸°ë³¸ ìŠ¤íƒ¯: HP ${baseHP}, DMG ${baseDamage}`, 'text-cyan-400');

            generateDungeon(); 
            
            calculateFOV(); 
            renderDungeon(); 
            updateStatus(); 

            document.addEventListener('keydown', handleInput);
        }

        window.onload = initializeGame;
    </script>

</body>
</html>
