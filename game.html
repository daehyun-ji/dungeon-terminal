<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>던전 탐험</title>
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Retro 터미널 느낌을 위한 폰트 설정 */
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #000000; /* 검은색 배경 */
            color: #E0E0E0; /* 밝은 회색/흰색 글씨 */
            overflow: hidden; 
            font-size: clamp(0.8rem, 2vw, 1rem); 
        }
        /* 게임 영역에 레트로한 녹색 테두리 추가 */
        .game-area {
            border: 4px solid #00aa00;
            box-shadow: 0 0 10px #00aa00;
        }
        /* 던전 뷰포트 (ASCII 아트가 깨지지 않도록 pre-wrap 사용) */
        #dungeon-viewport {
            white-space: pre; 
            line-height: 1; 
            font-size: 1rem;
            color: #E0E0E0;
            user-select: none; 
        }
        /* 개별 타일 스타일 */
        .player { color: #ffff00; /* 노란색: @ */ }
        .wall { color: #555555; /* 어두운 회색: # */ }
        .floor { color: #444444; /* 아주 어두운 회색: . */ }
        .stairs { color: #00ffff; /* 밝은 청록색: > */ }
        .item { color: #ff00ff; /* 마젠타: % */ }
        
        /* 몬스터 스타일 */
        .monster-S { color: #ff8800; /* 주황색: 힘의 정수 드랍 몬스터 */ }
        .monster-H { color: #00ff00; /* 녹색: 체력의 정수 드랍 몬스터 */ }
        .monster-Y { color: #0088ff; /* 파란색: 회피의 정수 드랍 몬스터 */ }
        .monster-P { color: #8800ff; /* 보라색 */ }
        .monster-O { color: #ff0088; /* 핑크색 */ }

        /* 보스 몬스터 스타일: 붉게 빛나는 효과 */
        .boss-glow {
            color: #ff4444; /* Bright Red */
            text-shadow: 0 0 5px #ff0000, 0 0 10px #880000; 
        }

        /* 새로운 스타일: 한 번 봤지만 현재 시야 밖인 타일 (어둡게) */
        .dimmed { 
            color: #333333 !important; 
        }
        .dimmed.floor { color: #222222 !important; } 
        .dimmed.stairs { color: #005555 !important; } 
        .dimmed.item { color: #550055 !important; } /* 어두운 아이템 */

        /* 인벤토리 스타일 */
        .inventory-slot {
            display: inline-block;
            padding: 0 0.5rem;
            border: 1px solid #333;
            margin-right: 0.25rem;
            font-weight: bold;
            min-width: 6rem;
            text-align: center;
        }
        
        /* 커스텀 모달 스타일 */
        .modal {
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
        }
        .modal-content {
            border: 3px solid #00aa00;
            box-shadow: 0 0 15px #00aa00;
            background-color: #111;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <!-- 메인 게임 컨테이너 -->
    <div class="game-area p-4 m-4 w-full max-w-6xl h-full max-h-[95vh] flex flex-row rounded-lg">

        <!-- 좌측: 맵, 상태, 로그 -->
        <div class="flex-grow flex flex-col w-full md:w-3/4 pr-4">
            <!-- 상단 상태바 -->
            <div class="p-2 border-b border-gray-700 mb-2 flex flex-wrap justify-between text-sm sm:text-base">
                <div class="flex flex-col sm:flex-row sm:space-x-4 mb-2 sm:mb-0 w-full sm:w-auto">
                    <span id="floor-display">Floor: 1</span>
                    <span id="player-level-display">P-Level: 1</span>
                    <span id="hp-display" class="text-red-500">HP: 20/20</span>
                    <span id="hunger-display" class="text-yellow-400">Hunger: 100%</span>
                    <span id="gold-display">Gold: 0</span>
                    <span id="time-display">Turn: 0</span>
                </div>
                 <!-- 새로운 능력치 표시 -->
                <div class="flex space-x-4">
                    <span id="damage-display">DMG: 1</span>
                    <span id="evasion-display">EVA: 0%</span>
                </div>
            </div>
            
            <!-- 인벤토리 및 정수 칸 -->
            <div id="inventory-display" class="p-2 border-b border-gray-700 mb-4 text-xs sm:text-sm overflow-x-auto whitespace-nowrap">
                <!-- 인벤토리 슬롯 및 정수 표시 영역 -->
            </div>

            <!-- 던전 뷰포트 -->
            <div id="dungeon-viewport" class="flex-grow bg-black p-2 overflow-auto">
                <!-- 던전 맵이 여기에 로드됩니다. -->
            </div>

            <!-- 하단 메시지 로그 -->
            <div id="message-log" class="mt-4 p-2 h-16 border-t border-gray-700 text-xs sm:text-sm overflow-y-auto">
                <span class="text-green-400">[SYSTEM]</span> 던전 생성 완료. WASD/화살표로 이동, 1~5 키로 아이템을 사용하세요.
            </div>
        </div>

        <!-- 우측: 명예의 전당 (Hall of Fame) -->
        <div id="hall-of-fame-panel" class="w-full md:w-1/4 p-2 border-l border-gray-700 ml-4 hidden md:block overflow-y-auto">
            <h3 class="text-lg font-bold text-center text-yellow-500 mb-2 border-b border-gray-700 pb-1">명예의 전당 (Top 10)</h3>
            <div id="hall-of-fame-list" class="text-xs">
                <p class="text-gray-500 text-center">데이터 로드 중...</p>
            </div>
        </div>
    </div>

    <!-- 게임 오버/점수 기록 모달 (Custom Modal) -->
    <div id="score-modal" class="modal fixed inset-0 flex items-center justify-center hidden">
        <div class="modal-content p-6 rounded-lg w-full max-w-md">
            <h2 id="modal-title" class="text-xl font-bold text-red-500 mb-4 text-center">GAME OVER</h2>
            <p id="modal-message" class="mb-4 text-center"></p>
            <div id="modal-input-area" class="hidden">
                <label for="player-name" class="block mb-2 text-sm text-green-400">플레이어 이름 (3~10자):</label>
                <input type="text" id="player-name" class="w-full p-2 mb-4 bg-gray-800 border border-green-700 text-white rounded focus:outline-none focus:border-green-400" maxlength="10">
            </div>
            <div id="modal-buttons" class="flex justify-around">
                <button id="modal-confirm" class="bg-green-600 hover:bg-green-700 text-black font-bold py-2 px-4 rounded-full transition-colors hidden" disabled>기록하기</button>
                <button id="modal-cancel" class="bg-red-600 hover:bg-red-700 text-black font-bold py-2 px-4 rounded-full transition-colors">닫기</button>
            </div>
        </div>
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, onSnapshot, collection, query, orderBy, limit, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables
        let app;
        let db;
        let auth;
        let userId;

        // Firebase configuration and environment variables (MANDATORY)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // 던전 상수 (기존 코드 유지)
        const MAP_WIDTH = 60; 
        const MAP_HEIGHT = 30;
        const MAX_ROOMS = 12; 
        const MIN_ROOM_SIZE = 5;
        const MAX_ROOM_SIZE = 12; 
        const FOV_RADIUS = 7; 

        // 타일 정의
        const TILE_WALL = '#';
        const TILE_FLOOR = '.';
        const TILE_PLAYER = '@';
        const TILE_STAIRS = '>';
        const TILE_ITEM = '%'; 
        
        // 시야 상수
        const VISIBILITY_UNEXPLORED = 0; 
        const VISIBILITY_SEEN = 1;      
        const VISIBILITY_VISIBLE = 2;   
        
        // 인벤토리 및 배고픔 상수
        const INVENTORY_SIZE = 5;
        const MAX_HUNGER = 100;
        const HUNGER_DECAY_CHANCE = 0.15; 

        // 몬스터 심볼 정의 및 기본 템플릿 (기존 코드 유지)
        const MONSTER_TEMPLATES = {
            'S': { name: 'Slime', hp: 5, damage: 1, symbol: 'S' },
            'H': { name: 'Husk', hp: 5, damage: 1, symbol: 'H' },
            'Y': { name: 'Yeti', hp: 5, damage: 1, symbol: 'Y' },
            'P': { name: 'Piranha', hp: 5, damage: 1, symbol: 'P' },
            'O': { name: 'Ogre', hp: 5, damage: 1, symbol: 'O' }
        };
        const MONSTER_SYMBOLS = Object.keys(MONSTER_TEMPLATES);

        // 아이템 및 정수 정의 (기존 코드 유지)
        const ITEM_DEFINITIONS = [
            { id: 'bandage', symbol: TILE_ITEM, name: '붕대', type: 'consumable', use: 'turn-heal', effectValue: 1, turns: 2 },
            { id: 'food', symbol: TILE_ITEM, name: '음식', type: 'consumable', use: 'instant-hunger', effectValue: 50 },
        ];
        
        // 정수 정의 (기존 코드 유지)
        const ESSENCE_DEFINITIONS = {
            'S': { name: '힘의 정수', stat: 'damage', value: 1, dropChance: 0.25, color: 'text-yellow-500' },
            'H': { name: '체력의 정수', stat: 'maxHp', value: 5, dropChance: 0.25, color: 'text-green-500' },
            'Y': { name: '회피의 정수', stat: 'evasion', value: 5, dropChance: 0.25, color: 'text-cyan-500' } 
        };


        // 전역 상태 변수 (기존 코드 유지)
        let gameState = {
            mapWidth: MAP_WIDTH, 
            mapHeight: MAP_HEIGHT, 
            playerX: 0,
            playerY: 0,
            map: [], 
            visibilityMap: [], 
            turn: 0,
            rooms: [], 
            currentLevel: 1, // 현재 층 레벨
            isBossFloor: false, // 현재 층이 보스 층인지
            isBossDefeated: false, // 현재 보스 층에서 보스를 잡았는지
            player: { 
                hp: 20,
                maxHp: 20,
                gold: 0,
                level: 1,       // 플레이어 전투 레벨 (몬스터 처치로 상승)
                damage: 1,      
                evasion: 0,     
                statusEffects: [], 
            },
            hunger: MAX_HUNGER,         
            inventory: new Array(INVENTORY_SIZE).fill(null), 
            essences: { damage: 0, maxHp: 0, evasion: 0 }, 
            items: [],           
            monsters: [],        
        };

        // DOM 요소 (기존 코드 유지)
        const dungeonViewport = document.getElementById('dungeon-viewport');
        const INVENTORY_DISPLAY = document.getElementById('inventory-display');
        const STATUS_DISPLAY = {
            floor: document.getElementById('floor-display'), 
            playerLevel: document.getElementById('player-level-display'), 
            hp: document.getElementById('hp-display'),
            hunger: document.getElementById('hunger-display'),
            gold: document.getElementById('gold-display'),
            time: document.getElementById('time-display'),
            damage: document.getElementById('damage-display'),
            evasion: document.getElementById('evasion-display')
        };
        const scoreModal = document.getElementById('score-modal');
        const playerNameInput = document.getElementById('player-name');
        const modalConfirmBtn = document.getElementById('modal-confirm');
        const hallOfFameList = document.getElementById('hall-of-fame-list');


        /**
         * @function generateUUID
         */
        const generateUUID = () => crypto.randomUUID();

        /**
         * @function getRandomInt
         */
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        /**
         * @function logMessage
         */
        function logMessage(text, color = 'text-white') {
            const log = document.getElementById('message-log');
            const messageElement = document.createElement('div');
            if (log.childElementCount > 50) {
                log.removeChild(log.firstChild);
            }
            messageElement.innerHTML = `<span class="${color}">${text}</span>`;
            log.appendChild(messageElement);
            log.scrollTop = log.scrollHeight;
        }
        
        /**
         * @function getTile / setTile
         */
        function getTile(x, y) {
            if (y >= 0 && y < gameState.mapHeight && x >= 0 && x < gameState.mapWidth) {
                return gameState.map[y][x];
            }
            return TILE_WALL; 
        }

        function setTile(x, y, tile) {
            if (y >= 0 && y < gameState.mapHeight && x >= 0 && x < gameState.mapWidth) {
                gameState.map[y][x] = tile;
                return true;
            }
            return false;
        }

        /**
         * @function getMonsterBaseStats
         * @description 몬스터의 기본 스탯을 계산합니다. (3층마다 공격력 +1)
         */
        function getMonsterBaseStats(currentLevel) {
            // HP: 1층 5, 2층마다 +1
            const baseHP = 5 + Math.floor((currentLevel - 1) / 2); 
            
            // Damage: 1층 1, 3층마다 +1 (수정된 로직 반영)
            const baseDamage = 1 + Math.floor(currentLevel / 3); 
            
            return { hp: baseHP, damage: baseDamage };
        }

        /**
         * @function getMonsterStats
         */
        function getMonsterStats(templateSymbol, isBoss) {
            const template = MONSTER_TEMPLATES[templateSymbol];
            const { hp: baseHP, damage: baseDamage } = getMonsterBaseStats(gameState.currentLevel);

            let finalHP = baseHP;
            let finalDamage = baseDamage;
            let finalName = template.name;
            let isBossType = isBoss;

            if (isBoss) {
                // 보스 보너스: HP +5, Damage +2
                finalHP += 5;
                finalDamage += 2;
                finalName = `[BOSS] 붉게 빛나는 ${template.name}`;
            }

            return { 
                ...template,
                name: finalName,
                hp: finalHP, 
                maxHp: finalHP, 
                damage: finalDamage,
                isBoss: isBossType 
            };
        }

        /**
         * @function placeEntity
         */
        function placeEntity(entityList, entityData, tileSymbol, count = 1) {
            // 기존 코드 유지
            const floorTiles = [];
            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (getTile(x, y) === TILE_FLOOR) {
                        const isOccupied = entityList.some(e => e.x === x && e.y === y);
                        // 플레이어나 계단이 있는 곳에는 배치하지 않음 (계단은 나중에 바닥으로 인식됨)
                        if (!isOccupied && (x !== gameState.playerX || y !== gameState.playerY) && getTile(x, y) !== TILE_STAIRS) {
                            floorTiles.push({ x, y });
                        }
                    }
                }
            }

            for (let i = 0; i < count && floorTiles.length > 0; i++) {
                const index = getRandomInt(0, floorTiles.length - 1);
                const pos = floorTiles[index];
                
                let newEntity = { x: pos.x, y: pos.y, id: generateUUID(), data: entityData };
                
                if (tileSymbol !== TILE_ITEM) {
                    newEntity.data = JSON.parse(JSON.stringify(entityData));
                }

                entityList.push(newEntity);
                
                floorTiles.splice(index, 1); 
            }
        }
        
        /**
         * 던전 생성 관련 함수 (기존 코드 유지)
         */
        function createRoom(room) {
            for (let y = room.y; y < room.y + room.h; y++) {
                for (let x = room.x; x < room.x + room.w; x++) {
                    setTile(x, y, TILE_FLOOR);
                }
            }
        }
        
        function createCorridor(startRoom, endRoom) {
            const startX = startRoom.x + Math.floor(startRoom.w / 2);
            const startY = startRoom.y + Math.floor(startRoom.h / 2);
            const endX = endRoom.x + Math.floor(endRoom.w / 2);
            const endY = endRoom.y + Math.floor(endRoom.h / 2);

            let x = startX;
            let y = startY;

            while (x !== endX) {
                setTile(x, y, TILE_FLOOR);
                x += (x < endX ? 1 : -1);
            }

            while (y !== endY) {
                setTile(x, y, TILE_FLOOR);
                y += (y < endY ? 1 : -1);
            }
        }

        function generateDungeon() {
            // 기존 코드 유지
            gameState.map = [];
            gameState.visibilityMap = []; 
            gameState.rooms = [];
            gameState.items = []; 
            gameState.monsters = []; 

            // 5층마다 보스 층 설정
            gameState.isBossFloor = (gameState.currentLevel % 5 === 0);
            gameState.isBossDefeated = false; // 새 층에서는 보스 미처치 상태로 시작


            for (let y = 0; y < gameState.mapHeight; y++) {
                gameState.map.push(new Array(gameState.mapWidth).fill(TILE_WALL));
                gameState.visibilityMap.push(new Array(gameState.mapWidth).fill(VISIBILITY_UNEXPLORED));
            }

            // 방 생성 
            for (let i = 0; i < 100; i++) { 
                if (gameState.rooms.length >= MAX_ROOMS) break;
                const w = getRandomInt(MIN_ROOM_SIZE, MAX_ROOM_SIZE);
                const h = getRandomInt(MIN_ROOM_SIZE, MAX_ROOM_SIZE);
                const x = getRandomInt(1, gameState.mapWidth - w - 1);
                const y = getRandomInt(1, gameState.mapHeight - h - 1);
                const newRoom = { x, y, w, h };
                let overlaps = false;
                for (const existingRoom of gameState.rooms) {
                    if (x < existingRoom.x + existingRoom.w + 1 &&
                        x + w > existingRoom.x - 1 &&
                        y < existingRoom.y + existingRoom.h + 1 &&
                        y + h > existingRoom.y - 1) {
                        overlaps = true;
                        break;
                    }
                }
                if (!overlaps) {
                    createRoom(newRoom);
                    gameState.rooms.push(newRoom);
                }
            }
            
            // 방 연결 
            for (let i = 1; i < gameState.rooms.length; i++) {
                createCorridor(gameState.rooms[i - 1], gameState.rooms[i]);
            }

            // 플레이어와 계단 배치
            const floorTiles = [];
            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (getTile(x, y) === TILE_FLOOR) {
                        floorTiles.push({ x, y });
                    }
                }
            }

            if (floorTiles.length > 0) {
                const playerPosIndex = getRandomInt(0, floorTiles.length - 1);
                const playerPos = floorTiles[playerPosIndex];
                gameState.playerX = playerPos.x;
                gameState.playerY = playerPos.y;
                floorTiles.splice(playerPosIndex, 1); 

                if (floorTiles.length > 0) {
                    const stairsPos = floorTiles[getRandomInt(0, floorTiles.length - 1)];
                    setTile(stairsPos.x, stairsPos.y, TILE_STAIRS);
                }
            } else {
                logMessage("[ERROR] 던전 생성에 실패했습니다.", 'text-red-500');
                gameState.playerX = 5;
                gameState.playerY = 5;
            }

            // 몬스터 및 아이템 배치
            const entityCount = Math.floor(gameState.rooms.length * 0.7);

            // 아이템 배치 
            for (let i = 0; i < entityCount; i++) {
                const itemType = (i % 2 === 0) ? ITEM_DEFINITIONS.find(d => d.id === 'food') : ITEM_DEFINITIONS.find(d => d.id === 'bandage');
                placeEntity(gameState.items, itemType, TILE_ITEM, 1);
            }
            
            // 몬스터 배치 (보스 로직 적용)
            if (gameState.isBossFloor) {
                // 보스 층: 1마리의 보스만 배치
                const symbol = MONSTER_SYMBOLS[getRandomInt(0, MONSTER_SYMBOLS.length - 1)];
                const bossStats = getMonsterStats(symbol, true);
                placeEntity(gameState.monsters, bossStats, symbol, 1);
                logMessage(`[WARNING] 🚨 ${gameState.currentLevel}층의 보스 ${bossStats.name}가 나타났습니다!`, 'text-red-500 font-bold');
            } else {
                // 일반 층: 일반 몬스터 배치
                for (let i = 0; i < entityCount; i++) {
                    const symbol = MONSTER_SYMBOLS[getRandomInt(0, MONSTER_SYMBOLS.length - 1)];
                    const monsterStats = getMonsterStats(symbol, false);
                    placeEntity(gameState.monsters, monsterStats, symbol, 1);
                }
            }
        }


        /**
         * @function calculateFOV
         */
        function calculateFOV() {
            // 기존 코드 유지
            const px = gameState.playerX;
            const py = gameState.playerY;
            const radius = FOV_RADIUS;
            const radiusSq = radius * radius;

            for (let y = 0; y < gameState.mapHeight; y++) {
                for (let x = 0; x < gameState.mapWidth; x++) {
                    if (gameState.visibilityMap[y][x] === VISIBILITY_VISIBLE) {
                        gameState.visibilityMap[y][x] = VISIBILITY_SEEN;
                    }
                }
            }

            for (let y = py - radius; y <= py + radius; y++) {
                for (let x = px - radius; x <= px + radius; x++) {
                    if (y >= 0 && y < gameState.mapHeight && x >= 0 && x < gameState.mapWidth) {
                        const dx = x - px;
                        const dy = y - py;
                        if (dx * dx + dy * dy <= radiusSq) { 
                            gameState.visibilityMap[y][x] = VISIBILITY_VISIBLE;
                        }
                    }
                }
            }
        }


        /**
         * @function renderDungeon
         */
        function renderDungeon() {
            // 기존 코드 유지
            let mapHTML = '';
            const px = gameState.playerX;
            const py = gameState.playerY;

            // 몬스터와 아이템 위치를 쉽게 찾기 위한 맵 생성
            const entityMap = {};
            gameState.items.forEach(item => entityMap[`${item.x},${item.y}`] = item.data.symbol);
            gameState.monsters.forEach(monster => entityMap[`${monster.x},${monster.y}`] = monster); 

            for (let y = 0; y < gameState.mapHeight; y++) {
                let line = '';
                for (let x = 0; x < gameState.mapWidth; x++) {
                    const visibility = gameState.visibilityMap[y][x];
                    let tile = gameState.map[y][x];
                    let tileClass = '';
                    let isPlayer = (x === px && y === py);
                    const entity = entityMap[`${x},${y}`];
                    const entitySymbol = entity ? (entity.data ? entity.data.symbol : entity) : null;

                    if (visibility === VISIBILITY_UNEXPLORED) {
                        line += ' '; 
                        continue;
                    }

                    // 1. 타일 심볼 결정 (플레이어 > 몬스터 > 아이템 > 맵 타일 순으로 우선순위)
                    if (isPlayer) {
                        tile = TILE_PLAYER;
                        tileClass = 'player';
                    } else if (entitySymbol) {
                        tile = entitySymbol;
                        if (tile === TILE_ITEM) {
                            tileClass = 'item';
                        } else if (MONSTER_SYMBOLS.includes(tile)) {
                            tileClass = `monster-${tile}`;
                            // 보스 몬스터 스타일링 추가
                            if (entity.data.isBoss) {
                                tileClass += ' boss-glow'; 
                            }
                        }
                    } else {
                        // 맵 타일
                        switch(tile) {
                            case TILE_WALL: tileClass = 'wall'; break;
                            case TILE_FLOOR: tileClass = 'floor'; break;
                            case TILE_STAIRS: tileClass = 'stairs'; break;
                            default: tileClass = '';
                        }
                    }

                    if (visibility === VISIBILITY_SEEN) {
                        tileClass += ' dimmed';
                    }
                    
                    line += `<span class="${tileClass}">${tile}</span>`;
                }
                mapHTML += line + '\n';
            }
            dungeonViewport.innerHTML = mapHTML.trim();
        }
        
        /**
         * @function updateStatus
         */
        function updateStatus() {
            // 기존 코드 유지
            const player = gameState.player;
            const essences = gameState.essences;

            STATUS_DISPLAY.floor.textContent = `Floor: ${gameState.currentLevel}`;
            STATUS_DISPLAY.playerLevel.textContent = `P-Level: ${player.level}`; 
            STATUS_DISPLAY.time.textContent = `Turn: ${gameState.turn}`;
            STATUS_DISPLAY.gold.textContent = `Gold: ${player.gold}`;
            
            // HP 표시 (정수 효과 반영)
            const currentMaxHp = player.maxHp + essences.maxHp;
            STATUS_DISPLAY.hp.textContent = `HP: ${player.hp}/${currentMaxHp}`;
            
            // 배고픔 표시
            const hungerColor = gameState.hunger > 30 ? 'text-yellow-400' : 'text-red-500';
            STATUS_DISPLAY.hunger.innerHTML = `<span class="${hungerColor}">Hunger: ${gameState.hunger}%</span>`;

            // 능력치 표시 (정수와 플레이어 레벨 데미지 반영)
            const totalDamage = player.damage + essences.damage; 
            STATUS_DISPLAY.damage.textContent = `DMG: ${totalDamage}`;
            STATUS_DISPLAY.evasion.textContent = `EVA: ${player.evasion + essences.evasion}%`;

            // 인벤토리 및 정수 표시
            let invHTML = '인벤토리: ';
            gameState.inventory.forEach((item, index) => {
                const slotNumber = index + 1;
                const itemName = item ? item.name : '빈 공간';
                const itemColor = item ? (item.id === 'food' ? 'text-yellow-300' : 'text-lime-300') : 'text-gray-500';
                invHTML += `<span class="inventory-slot ${itemColor}">${slotNumber}. [${itemName}]</span>`;
            });

            invHTML += ' | 정수: ';
            invHTML += `<span class="${ESSENCE_DEFINITIONS.S.color}">힘: ${essences.damage}</span>, `;
            invHTML += `<span class="${ESSENCE_DEFINITIONS.H.color}">체력: ${essences.maxHp}</span>, `;
            invHTML += `<span class="${ESSENCE_DEFINITIONS.Y.color}">회피: ${essences.evasion}</span>`;

            INVENTORY_DISPLAY.innerHTML = invHTML;
        }

        /**
         * @function addItem
         */
        function addItem(item) {
            // 기존 코드 유지
            const emptySlot = gameState.inventory.findIndex(slot => slot === null);
            if (emptySlot !== -1) {
                gameState.inventory[emptySlot] = item;
                logMessage(`[ITEM] ${item.name}을(를) 인벤토리 ${emptySlot + 1}번 슬롯에 획득했습니다.`, 'text-lime-400');
                return true;
            } else {
                logMessage("[ITEM] 인벤토리가 가득 찼습니다. 아이템을 놓칠 수 없습니다.", 'text-red-400');
                return false;
            }
        }
        
        /**
         * @function useItem
         */
        function useItem(slotIndex) {
            // 기존 코드 유지
            const item = gameState.inventory[slotIndex];

            if (!item) {
                logMessage(`[INVENTORY] ${slotIndex + 1}번 슬롯은 비어 있습니다.`, 'text-gray-500');
                return;
            }

            logMessage(`[INVENTORY] ${item.name}을(를) 사용했습니다.`, 'text-lime-400');
            
            let used = false;
            const player = gameState.player;
            const currentMaxHp = player.maxHp + gameState.essences.maxHp;

            if (item.type === 'consumable') {
                if (item.use === 'turn-heal') {
                    player.statusEffects.push({ 
                        name: item.name, 
                        remainingTurns: item.turns, 
                        effect: 'heal',
                        value: item.effectValue 
                    });
                    logMessage(`[EFFECT] ${item.turns}턴 동안 매 턴 HP ${item.effectValue}씩 회복합니다.`, 'text-green-500');
                    used = true;
                } else if (item.use === 'instant-hunger') {
                    gameState.hunger = Math.min(MAX_HUNGER, gameState.hunger + item.effectValue);
                    logMessage(`[HUNGER] 배고픔 ${item.effectValue}% 회복!`, 'text-yellow-300');
                    used = true;
                }
            } 
            
            if (used) {
                gameState.inventory[slotIndex] = null; 
                updateStatus();
                gameState.turn++; 
                runGameTurn();
            }
        }


        /**
         * @function checkEssenceDrop
         */
        function checkEssenceDrop(monster) {
            // 기존 코드 유지
            const symbol = monster.data.symbol;
            const essenceDef = ESSENCE_DEFINITIONS[symbol];

            if (essenceDef && Math.random() < essenceDef.dropChance) { 
                const statKey = essenceDef.stat;
                gameState.essences[statKey] += essenceDef.value;
                logMessage(`[DROP] ${monster.data.name} 처치 후 ${essenceDef.name}을(를) 획득했습니다! (${essenceDef.stat} +${essenceDef.value})`, essenceDef.color);
            }
        }

        /**
         * @function tryLevelUp
         */
        function tryLevelUp() {
            // 기존 코드 유지
            if (Math.random() < 0.25) { 
                const player = gameState.player;
                const currentMaxHp = player.maxHp + gameState.essences.maxHp;

                player.level++;
                player.damage += 1; // 기본 공격력 1 상승
                player.hp = currentMaxHp; // HP 완전 회복
                
                logMessage(`[LEVEL UP] 몬스터 처치로 레벨업 했습니다! (Lv ${player.level})`, 'text-yellow-400 font-bold');
                logMessage(`[BONUS] HP 완전 회복 및 공격력 +1 상승! (DMG: ${player.damage + gameState.essences.damage})`, 'text-green-400');
            }
        }
        
        /**
         * @function checkCombat
         */
        function checkCombat(x, y) {
            // 기존 코드 유지, 사망 체크 후 handleGameOver 호출
            const monsterIndex = gameState.monsters.findIndex(m => m.x === x && m.y === y);

            if (monsterIndex !== -1) {
                const monster = gameState.monsters[monsterIndex];
                const player = gameState.player;
                
                const totalPlayerDamage = player.damage + gameState.essences.damage;
                
                logMessage(`[COMBAT] ${monster.data.name}(HP: ${monster.data.hp})을(를) 공격! (DMG: ${totalPlayerDamage})`, 'text-orange-500');
                
                if (Math.random() < 0.5) { 
                     monster.data.hp -= totalPlayerDamage;
                     logMessage(`[HIT] 명중! ${totalPlayerDamage} 데미지를 입혔습니다. 몬스터 잔여 HP: ${Math.max(0, monster.data.hp)}`);
                } else {
                     logMessage(`[MISS] 공격이 빗나갔습니다.`, 'text-gray-500');
                }
                
                if (monster.data.hp <= 0) {
                    logMessage(`[VICTORY] ${monster.data.name}을(를) 처치했습니다.`, 'text-green-500');
                    
                    if (monster.data.isBoss) {
                        gameState.isBossDefeated = true;
                        logMessage("[BOSS] 보스를 쓰러뜨려 다음 층으로 가는 길이 열렸습니다!", 'text-green-500 font-bold');
                    }
                    
                    checkEssenceDrop(monster); 
                    tryLevelUp(); 
                    gameState.monsters.splice(monsterIndex, 1); 

                    return true; 
                }

                if (Math.random() < 0.5) {
                    const monsterDamage = monster.data.damage; 
                    gameState.player.hp = Math.max(0, gameState.player.hp - monsterDamage);
                    logMessage(`[ATTACKED] ${monster.data.name}의 반격! ${monsterDamage} 데미지를 입었습니다. (HP: ${gameState.player.hp})`, 'text-red-600');
                    if (gameState.player.hp <= 0) {
                        handleGameOver("[GAME OVER] 몬스터의 반격으로 쓰러졌습니다.");
                    }
                } else {
                    logMessage(`[MISS] ${monster.data.name}의 공격이 빗나갔습니다. (몬스터 HP: ${monster.data.hp})`, 'text-gray-500');
                }

                return false;
            }
            return false;
        }
        
        /**
         * @function canMove
         */
        function canMove(x, y, currentMonsterId = null) {
            // 기존 코드 유지
            if (x < 0 || x >= gameState.mapWidth || y < 0 || y >= gameState.mapHeight) {
                return false; 
            }
            if (getTile(x, y) === TILE_WALL) {
                return false; 
            }

            if (getTile(x, y) === TILE_STAIRS) {
                return true;
            }
            
            if (gameState.monsters.some(m => m.id !== currentMonsterId && m.x === x && m.y === y)) {
                return false;
            }
            
            return true; 
        }

        /**
         * @function moveMonsters
         */
        function moveMonsters() {
            // 기존 코드 유지, 사망 체크 후 handleGameOver 호출
            const px = gameState.playerX;
            const py = gameState.playerY;

            const currentMonsters = [...gameState.monsters]; 

            currentMonsters.forEach(monster => {
                const mx = monster.x;
                const my = monster.y;
                
                let finalDx = 0;
                let finalDy = 0;
                let isChasing = gameState.visibilityMap[my][mx] === VISIBILITY_VISIBLE; 

                if (isChasing) {
                    const targetDx = mx < px ? 1 : (mx > px ? -1 : 0);
                    const targetDy = my < py ? 1 : (my > py ? -1 : 0);

                    if (Math.abs(mx - px) >= Math.abs(my - py)) {
                        if (targetDx !== 0 && (canMove(mx + targetDx, my, monster.id) || (mx + targetDx === px && my === py))) {
                            finalDx = targetDx;
                        } else if (targetDy !== 0 && (canMove(mx, my + targetDy, monster.id) || (mx === px && my + targetDy === py))) {
                            finalDy = targetDy;
                        }
                    } else {
                        if (targetDy !== 0 && (canMove(mx, my + targetDy, monster.id) || (mx === px && my + targetDy === py))) {
                            finalDy = targetDy;
                        } else if (targetDx !== 0 && (canMove(mx + targetDx, my, monster.id) || (mx + targetDx === px && my + targetDy === py))) {
                            finalDx = targetDx;
                        }
                    }
                } 
                
                if (!isChasing || (finalDx === 0 && finalDy === 0)) {
                    const randomMoves = [{dx: 0, dy: 1}, {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 0}]; 
                    const {dx, dy} = randomMoves[getRandomInt(0, randomMoves.length - 1)];
                    
                    if (canMove(mx + dx, my + dy, monster.id)) {
                         finalDx = dx;
                         finalDy = dy;
                    }
                }

                if (finalDx !== 0 || finalDy !== 0) {
                    const nextX = mx + finalDx;
                    const nextY = my + finalDy;

                    if (nextX === px && nextY === py) {
                        if (Math.random() < 0.5) {
                            const monsterDamage = monster.data.damage; 
                            const currentMaxHp = gameState.player.maxHp + gameState.essences.maxHp;
                            gameState.player.hp = Math.max(0, gameState.player.hp - monsterDamage);
                            logMessage(`[ATTACKED] ${monster.data.name}의 공격! ${monsterDamage} 데미지를 입었습니다. (HP: ${gameState.player.hp}/${currentMaxHp})`, 'text-red-600');
                        } else {
                            logMessage(`[MISS] ${monster.data.name}의 공격이 빗나갔습니다.`, 'text-gray-500');
                        }
                    } else {
                        monster.x = nextX;
                        monster.y = nextY;
                    }
                }
            });
            
            if (gameState.player.hp <= 0) {
                handleGameOver("[GAME OVER] 몬스터의 공격으로 쓰러졌습니다.");
            }
        }


        /**
         * @function applyStatusEffects
         */
        function applyStatusEffects() {
            // 기존 코드 유지, 사망 체크 후 handleGameOver 호출
            const player = gameState.player;
            const currentMaxHp = player.maxHp + gameState.essences.maxHp;

            // 1. 상태 효과 적용 및 감소
            player.statusEffects = player.statusEffects.filter(effect => {
                if (effect.effect === 'heal') {
                    if (player.hp < currentMaxHp) {
                         player.hp = Math.min(currentMaxHp, player.hp + effect.value);
                         logMessage(`[HEAL] ${effect.name} 효과로 HP ${effect.value} 회복.`, 'text-green-500');
                    }
                }

                effect.remainingTurns--;
                if (effect.remainingTurns > 0) {
                    return true;
                } else {
                    logMessage(`[EFFECT] ${effect.name} 효과가 끝났습니다.`, 'text-gray-500');
                    return false;
                }
            });

            // 2. 배고픔 감소 처리 및 페널티
            if (gameState.hunger > 0) {
                if (Math.random() < HUNGER_DECAY_CHANCE) {
                    gameState.hunger = Math.max(0, gameState.hunger - 1);
                    if (gameState.hunger <= 30 && gameState.hunger > 0) {
                         logMessage("[HUNGER] 배가 고프기 시작합니다.", 'text-red-400');
                    } else if (gameState.hunger === 0) {
                        logMessage("[HUNGER] 배고픔으로 고통받기 시작합니다!", 'text-red-500');
                    }
                }
            } else if (gameState.hunger === 0) {
                if (player.hp > 0) {
                    player.hp = Math.max(0, player.hp - 1);
                    logMessage("[DAMAGE] 배고픔 때문에 HP가 1 감소했습니다.", 'text-red-500');
                }
            }

            // 3. 사망 체크
            if (player.hp <= 0) {
                handleGameOver("[GAME OVER] 당신은 던전에서 쓰러졌습니다.");
            }
        }

        // ------------------------------------
        // 명예의 전당 (Hall of Fame) 관련 함수
        // ------------------------------------
        
        /**
         * @function saveScore
         * @description Firestore에 게임 점수 기록을 저장합니다.
         */
        async function saveScore(playerName) {
            if (!db || !userId) {
                logMessage("[ERROR] 데이터베이스 연결 오류: 점수를 기록할 수 없습니다.", 'text-red-500');
                return;
            }

            const scoreData = {
                name: playerName,
                level: gameState.currentLevel,
                turn: gameState.turn,
                playerLevel: gameState.player.level,
                gold: gameState.player.gold,
                userId: userId,
                // 정수 (Essences)는 JSON 문자열로 저장하여 데이터 무결성을 유지
                essences: JSON.stringify(gameState.essences), 
                date: serverTimestamp(),
            };

            try {
                const hallOfFameCollection = collection(db, `artifacts/${appId}/public/data/hall_of_fame`);
                await addDoc(hallOfFameCollection, scoreData);
                logMessage(`[HALL OF FAME] ${playerName}님의 점수가 명예의 전당에 기록되었습니다!`, 'text-yellow-500 font-bold');
                fetchHallOfFame(); // 기록 후 목록 업데이트
            } catch (error) {
                console.error("Error writing document: ", error);
                logMessage("[ERROR] 점수 기록 중 오류가 발생했습니다.", 'text-red-500');
            }
        }
        
        /**
         * @function fetchHallOfFame
         * @description Firestore에서 명예의 전당 목록을 불러와 UI를 업데이트합니다.
         */
        function fetchHallOfFame() {
            if (!db) return;

            try {
                const hallOfFameCollection = collection(db, `artifacts/${appId}/public/data/hall_of_fame`);
                
                // 최고 층수(level), 플레이어 레벨(playerLevel), 턴 수(turn) 순으로 정렬
                const q = query(hallOfFameCollection, 
                                // level은 내림차순 (높을수록 좋음)
                                // playerLevel도 내림차순
                                // turn은 오름차순 (낮을수록 좋음)
                                orderBy("level", "desc"),
                                orderBy("playerLevel", "desc"),
                                orderBy("turn", "asc"),
                                limit(10));
                
                // onSnapshot으로 실시간 업데이트
                onSnapshot(q, (snapshot) => {
                    let listHTML = '';
                    snapshot.forEach((doc, index) => {
                        const data = doc.data();
                        
                        // Essences 데이터 파싱
                        let essencesData = { damage: 0, maxHp: 0, evasion: 0 };
                        try {
                            essencesData = JSON.parse(data.essences);
                        } catch (e) {
                            console.error("Essences parsing error:", e);
                        }

                        // 날짜 포맷팅 (date가 undefined일 경우를 대비)
                        const dateStr = data.date ? new Date(data.date.seconds * 1000).toLocaleDateString('ko-KR') : '날짜 없음';

                        listHTML += `
                            <div class="border-b border-gray-900 pb-1 mb-1 ${index === 0 ? 'text-yellow-400 font-extrabold' : ''}">
                                <div class="flex justify-between">
                                    <span>#${index + 1}. ${data.name}</span>
                                    <span class="text-gray-500">${dateStr}</span>
                                </div>
                                <div>
                                    <span class="text-red-400">Lv ${data.playerLevel}</span> | 
                                    <span class="text-green-400">F${data.level}</span> | 
                                    <span class="text-cyan-400">${data.turn}턴</span>
                                </div>
                                <div class="text-xs text-gray-400">
                                    힘 ${essencesData.damage} | 체력 ${essencesData.maxHp} | 회피 ${essencesData.evasion}
                                </div>
                            </div>
                        `;
                    });

                    if (listHTML === '') {
                        hallOfFameList.innerHTML = '<p class="text-gray-500 text-center">아직 기록된 점수가 없습니다.</p>';
                    } else {
                        hallOfFameList.innerHTML = listHTML;
                    }
                }, (error) => {
                    console.error("Error fetching Hall of Fame: ", error);
                    hallOfFameList.innerHTML = '<p class="text-red-500 text-center">명예의 전당 로드 오류.</p>';
                });

            } catch (error) {
                console.error("Firestore setup error:", error);
            }
        }
        
        /**
         * @function showGameOverModal
         * @description 게임 오버 후 점수 기록 여부를 묻는 모달을 표시합니다.
         */
        function showGameOverModal(canRecord) {
            const titleEl = document.getElementById('modal-title');
            const messageEl = document.getElementById('modal-message');
            const inputAreaEl = document.getElementById('modal-input-area');
            
            scoreModal.classList.remove('hidden');

            if (canRecord) {
                titleEl.textContent = "명예의 전당 기록";
                messageEl.innerHTML = `최고 기록 달성! ${gameState.currentLevel}층에 도달하셨습니다.<br>점수를 명예의 전당에 기록하시겠습니까?`;
                modalConfirmBtn.textContent = '기록하기';
                modalConfirmBtn.classList.remove('hidden');
                inputAreaEl.classList.remove('hidden');

                // 이름 유효성 검사 리스너
                playerNameInput.value = ''; // 초기화
                const validateName = () => {
                    const name = playerNameInput.value.trim();
                    if (name.length >= 3 && name.length <= 10) {
                        modalConfirmBtn.disabled = false;
                        modalConfirmBtn.classList.remove('bg-gray-500');
                        modalConfirmBtn.classList.add('bg-green-600');
                    } else {
                        modalConfirmBtn.disabled = true;
                        modalConfirmBtn.classList.remove('bg-green-600');
                        modalConfirmBtn.classList.add('bg-gray-500');
                    }
                };
                playerNameInput.oninput = validateName;
                validateName(); // 초기 상태 검사

                // 확인 버튼 클릭 리스너 (점수 저장)
                modalConfirmBtn.onclick = () => {
                    const name = playerNameInput.value.trim();
                    if (name.length >= 3 && name.length <= 10) {
                        saveScore(name);
                        scoreModal.classList.add('hidden');
                        logMessage(`[SYSTEM] 명예의 전당 기록을 요청했습니다.`, 'text-yellow-500');
                    } else {
                        logMessage("[SYSTEM] 이름은 3~10자여야 합니다.", 'text-red-500');
                    }
                };

            } else {
                // 기록 불가능 (20층 미만)
                titleEl.textContent = "GAME OVER";
                messageEl.textContent = `당신은 ${gameState.currentLevel}층에서 쓰러졌습니다.`;
                modalConfirmBtn.classList.add('hidden');
                inputAreaEl.classList.add('hidden');
                // 닫기 버튼만 작동
            }
            
            // 닫기 버튼 클릭 리스너 (모달 닫기)
            document.getElementById('modal-cancel').onclick = () => {
                scoreModal.classList.add('hidden');
            };
        }
        
        /**
         * @function handleGameOver
         * @description 게임 오버 발생 시 호출됩니다.
         */
        function handleGameOver(message) {
            logMessage(message, 'text-red-600 font-bold');
            document.removeEventListener('keydown', handleInput);

            // 20층 이상일 경우에만 기록 기회 제공
            const canRecord = gameState.currentLevel >= 20;

            showGameOverModal(canRecord);
        }

        /**
         * @function runGameTurn
         */
        function runGameTurn() {
            // 기존 코드 유지 (사망 체크는 moveMonsters, applyStatusEffects에서 처리)
            if (gameState.player.hp <= 0) return; 

            gameState.turn++;
            
            moveMonsters();
            
            // moveMonsters에서 사망 처리 후 runGameTurn이 호출되지 않도록 방어
            if (gameState.player.hp > 0) { 
                applyStatusEffects(); 
            }
            
            updateStatus();
            calculateFOV(); 
            renderDungeon();
        }

        /**
         * @function handleInput
         */
        function handleInput(event) {
            // 기존 코드 유지
            if (gameState.player.hp <= 0) return; 

            let dx = 0;
            let dy = 0;
            
            // 1. 이동 키 처리 (WASD 또는 화살표)
            switch (event.key) {
                case 'w': case 'W': case 'ArrowUp': dy = -1; break;
                case 's': case 'S': case 'ArrowDown': dy = 1; break;
                case 'a': case 'A': case 'ArrowLeft': dx = -1; break;
                case 'd': case 'D': case 'ArrowRight': dx = 1; break;
                
                // 2. 인벤토리 사용 키 처리 (1~5)
                case '1': useItem(0); return; 
                case '2': useItem(1); return;
                case '3': useItem(2); return;
                case '4': useItem(3); return;
                case '5': useItem(4); return;
                default: return; 
            }
            
            event.preventDefault(); 

            const newX = gameState.playerX + dx;
            const newY = gameState.playerY + dy;
            
            // 맵 경계 체크
            if (newX < 0 || newX >= gameState.mapWidth || newY < 0 || newY >= gameState.mapHeight) {
                return;
            }

            const targetTile = getTile(newX, newY);
            
            // 1. 벽 충돌
            if (targetTile === TILE_WALL) {
                return;
            }

            // 2. 몬스터 충돌 (전투)
            if (gameState.monsters.some(m => m.x === newX && m.y === newY)) {
                if (!checkCombat(newX, newY)) {
                    runGameTurn(); 
                    return;
                }
            }

            // 3. 아이템 획득
            const pickedItemIndex = gameState.items.findIndex(i => i.x === newX && i.y === newY);
            if (pickedItemIndex !== -1) {
                const item = gameState.items[pickedItemIndex].data;
                if (addItem(item)) {
                    gameState.items.splice(pickedItemIndex, 1);
                }
            }

            // 4. 계단 처리 (다음 층 이동) - 보스 층일 경우 조건부 이동
            if (targetTile === TILE_STAIRS) {
                if (gameState.isBossFloor && !gameState.isBossDefeated) {
                    logMessage("[BLOCKED] 보스를 처치해야만 다음 층으로 이동할 수 있습니다!", 'text-red-500 font-bold');
                    return;
                }
                generateNewLevel();
                return; 
            }

            // 5. 이동 실행
            gameState.playerX = newX;
            gameState.playerY = newY;
            
            runGameTurn();
        }
        
        /**
         * @function generateNewLevel
         */
        function generateNewLevel() {
            // 기존 코드 유지
            gameState.currentLevel++;
            gameState.turn = 0; 
            
            logMessage(`[MAP] ${gameState.currentLevel}층으로 내려갑니다...`, 'text-yellow-400');
            
            // 몬스터 및 플레이어 스탯 업데이트 로깅
            const { hp: baseHP, damage: baseDamage } = getMonsterBaseStats(gameState.currentLevel);
            logMessage(`[INFO] 몬스터 기본 스탯: HP ${baseHP}, DMG ${baseDamage}`, 'text-cyan-400');


            generateDungeon();
            
            calculateFOV(); 
            renderDungeon();
            updateStatus();

            logMessage(`[SYSTEM] ${gameState.currentLevel}층에 도착했습니다.`, 'text-green-400');
        }


        /**
         * @function initializeFirebase
         * @description Firebase를 초기화하고 사용자 인증을 처리합니다.
         */
        async function initializeFirebase() {
            if (!firebaseConfig) {
                logMessage("[ERROR] Firebase 설정이 제공되지 않았습니다. 명예의 전당 기능이 비활성화됩니다.", 'text-red-500');
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('Debug'); // 로그 수준 설정

                // 인증 처리
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // 인증 상태 변경 리스너
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        logMessage(`[DB] 사용자 인증 완료: ${userId.substring(0, 8)}...`, 'text-cyan-400');
                        fetchHallOfFame(); // 인증 후 명예의 전당 로드
                    } else {
                        logMessage("[DB] 사용자 인증에 실패했습니다.", 'text-red-500');
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                logMessage(`[ERROR] Firebase 초기화 중 오류가 발생했습니다: ${error.message}`, 'text-red-500');
            }
        }


        /**
         * @function initializeGame
         */
        async function initializeGame() {
            logMessage("[SYSTEM] 게임 시작 준비 중...", 'text-green-400');
            
            // 1. Firebase 초기화 및 인증 시도
            await initializeFirebase(); 
            
            // 2. 몬스터 스탯 로깅 및 던전 생성 (기존 코드 유지)
            const { hp: baseHP, damage: baseDamage } = getMonsterBaseStats(gameState.currentLevel);
            logMessage(`[INFO] 몬스터 기본 스탯: HP ${baseHP}, DMG ${baseDamage}`, 'text-cyan-400');

            generateDungeon(); 
            
            calculateFOV(); 
            renderDungeon(); 
            updateStatus(); 

            document.addEventListener('keydown', handleInput);
        }

        window.onload = initializeGame;
    </script>

</body>
</html>
